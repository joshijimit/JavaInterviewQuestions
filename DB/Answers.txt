insert into Answers values(1,1,'Ans) Yes an abstract class have a static method and it can be accessed by any other class(even not a concrete class).',1);
insert into Answers values(2,2,'Ans) Yes an abstract class have a default and parameterized constructors.',1);
insert into Answers values(3,3,'Ans) A static method cannot access non static variables or methods because static methods doesnt need the object to be 
accessed. So if a static method has non static variables or non static methods which has instantiated variables
they will no be intialized since the object is not created and this could result in an error.',1);
insert into Answers values(4,4,'Ans) The only difference between StringBuffer and StringBuilder is that StringBuilder is unsynchronized whereas StringBuffer is synchronized. So when the application needs to be run only in a single thread then it is better to use StringBuilder. StringBuilder is more efficient than StringBuffer.

Criteria to choose among StringBuffer and StringBuilder
1)If your text can change and will only be accessed from a single thread, use a StringBuilder 2)because StringBuilder is unsynchronized.
If your text can changes, and will be accessed from multiple threads, use a StringBuffer because StringBuffer is synchronous.',1);
insert into Answers values(5,5,'Ans) This is possible using
Runtime.getRuntime().addShutdownHook(Thread hook)
.

Straight from Java Spec:
This method registers a new virtual-machine shutdown hook.
The Java virtual machine shuts down in response to two kinds of events:
1. The program exits normally, when the last non-daemon thread exits or when the exit (equivalently, System.exit) method is invoked, or
2. The virtual machine is terminated in response to a user interrupt, such as typing ^C, or a system-wide event, such as user logoff or system shutdown.
A shutdown hook is simply an initialized but unstarted thread. When the virtual machine begins its shutdown sequence it will start all registered shutdown hooks in some unspecified order and let them run concurrently. When all the hooks have finished it will then run all uninvoked finalizers if finalization-on-exit has been enabled. Finally, the virtual machine will halt. Note that daemon threads will continue to run during the shutdown sequence, as will non-daemon threads if shutdown was initiated by invoking the exit method.
Once the shutdown sequence has begun it can be stopped only by invoking the halt method, which forcibly terminates the virtual machine.',1);
insert into Answers values(6,6,'Ans)
final
- constant declaration. A final variable act as constant, a final class is immutable and a final method cannot be ovrriden.

finally
- handles exception. The finally block is optional and provides a mechanism to clean up regardless of what happens within the try block (except System.exit(0) call). Use the finally block to close files or to release other system resources like database connections, statements etc.

finalize()
- method helps in garbage collection. A method that is invoked before an object is discarded by the garbage collector, allowing it to clean up its state. Should not be used to release non-memory resources like file handles, sockets, database connections etc because Java has only a finite number of these resources and you do not know when the garbage collection is going to kick in to release these non-memory resources through the finalize() method.',1);
insert into Answers values(7,7,'Ans) Each time an object is created in Java it goes into the area of memory known as
heap
. The primitive variables like int and double are allocated in the
stack
, if they are local method variables and in the
heap
if they are member variables (i.e. fields of a class). In Java methods local variables are pushed into
stack
when a method is invoked and stack pointer is decremented when a method call is completed.
In a multi-threaded application each thread will have its own stack but will share the same heap. This is why care should be taken in your code to avoid any
concurrent access issues in the heap space. The stack is threadsafe (each thread will have its own stack) but the heap is not threadsafe unless guarded with synchronisation through your code.',1);
insert into Answers values(8,8,'Ans) A method in stack is
re-entrant
allowing multiple concurrent invocations that do not interfere with each other.
A function is
recursive
if it calls itself. Given enough stack space, recursive method calls are perfectly valid in Java though it is tough to debug. Recursive functions are useful in removing iterations from many sorts of algorithms.
Allrecursive functions are re-entrant but not all re-entrant functions are recursive.

Idempotent methods
are methods, which are written in such a way that repeated calls to the same method with the same arguments yield same results. For example clustered EJBs, which are written with idempotent methods, can automatically recover from a server failure as long as it can reach another server.',1);
insert into Answers values(9,9,'Ans) Yes its possible using reflection.',1);
insert into Answers values(10,10,'Ans) The static block is loaded when the class is loaded by the JVM for the 1st time only whereas init {} block is loaded every time class is loaded. Also first the static block is loaded then the init block.

public class LoadingBlocks {

   static{
     System.out.println(""Inside static"");
   }

   {
     System.out.println(""Inside init"");
   }
   public static void main(String args[]){
     new LoadingBlocks();
     new LoadingBlocks();
     new LoadingBlocks();
   }
}

Output:

Inside static
Inside init
Inside init
Inside init',1);
insert into Answers values(11,11,'Ans) Local classes can most definitely reference instance variables. The reason they cannot reference non final local variables is because the local class instance can remain in memory after the method returns. When the method returns the local variables go out of scope, so a copy of them is needed. If the variables weren''t final then the copy of the variable in the method could change, while the copy in the local class didn''t, so they''d be out of synch.
Anonymous inner classes require final variables because of the way they are implemented in Java. An anonymous inner class (AIC) uses local variables by creating a private instance field which holds a copy of the value of the local variable. The inner class isn''t actually using the local variable, but a copy. It should be fairly obvious at this point that a ""Bad Thing""™ can happen if either the original value or the copied value changes; there will be some unexpected data synchronization problems. In order to prevent this kind of problem, Java requires you to mark local variables that will be used by the AIC as final (i.e., unchangeable). This guarantees that the inner class'' copies of local variables will always match the actual values.',1);
insert into Answers values(12,12,'Ans) An abstract class which has all methods as abstract and all fields are public static final.',1);
insert into Answers values(13,13,'Ans)
Method invocation
The Java programming language provides two basic kinds of methods: instance methods and class (or static) methods. The difference are:
1. Instance methods require an instance before they can be invoked, whereas class methods do not.
2. Instance methods use
dynamic (late) binding
, whereas class methods use
static (early) binding
.
When the Java virtual machine invokes a class method, it selects the method to invoke based on the type of the object reference, which is always known at compile-time. On the other hand, when the virtual machine invokes an instance method, it selects the method to invoke based on the actual class of the object, which may only be known at run time.',1);
insert into Answers values(14,14,'Ans)Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine.

Drawbacks of Reflection:
Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.

Performance Overhead:
Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.

Security Restrictions:
Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.

Exposure of Internals:
Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.',1);
insert into Answers values(15,15,'Ans)
Polymorphism
gives us the ultimate flexibility in extensibility. The abiltiy to define more than one function with the same name is called Polymorphism. In java,c++  there are two type of polymorphism: compile time polymorphism (overloading) and  runtime polymorphism (overriding).

When you override methods, JVM determines the proper methods to call at the  program''s run time, not at the compile time. Overriding occurs when a class  method has the same name and signature as a method in parent class.

Overloading  occurs when several methods have same names with


Overloading  is determined at the compile time.

Different  method signature and different number or type of parameters.
Same  method signature but different number of parameters.
Same  method signature and same number of parameters but of different type



Example of Overloading
     int add(int a,int b)
     float add(float a,int b)
     float add(int a ,float b)
     void add(float a)
     int add(int a)
     void add(int a)                 //error conflict with the  method int add(int a)



Example: Overloading



Class BookDetails{
            String title;
            String publisher;
            float price;

setBook(String title){
}
setBook(String title, String publisher){
}
setBook(String title, String publisher,float price){
}

}



Example: Overriding


class BookDetails{
            String title;

setBook(String title){
           }
}
class ScienceBook extends BookDetails{
            setBook(String title){}                                             //overriding
setBook(String title, String publisher,float price){
       }  //overloading

}',1);
insert into Answers values(16,16,'Ans) Inheritance  is the property which allows a Child class to inherit some properties from its parent  class. In Java this is achieved by using extends keyword. Only properties with access modifier public and protected can be  accessed in child class.


public class Parent{

public String parentName;
public int parentage;
public String familyName;
}

public class Child extends Parent{

public String childName;
public int childAge;

public void printMyName(){
System.out.println("" My name is ""+ chidName+"":"" +familyName)
}

}


In above example the child has inherit its family name from the parent class just by inheriting the class.',1);
insert into Answers values(17,17,'Ans) If a child  class inherits the property from multiple classes is known as multiple  inheritance.
Java does not allow to extend multiple classes but to  overcome this problem it allows to implement multiple Interfaces.',1);
insert into Answers values(18,18,'Ans) Abstraction  is way of converting real world objects in terms of class. For example creating  a class Vehicle and injecting properties into it. E.g

public class Vehicle {

public String colour;
public String model;
}',1);
insert into Answers values(19,19,'Ans) The encapsulation is achieved by combining the methods and attribute into a class. The class acts like a container encapsulating the properties. The users 
 are exposed mainly public methods.The idea behind is to hide how thinigs work and just exposing the requests a user can do.',1);
insert into Answers values(20,20,'Ans) Association
is a
relationship between two classes. In this relationship the object of one instance perform an action
         on behalf of the other class. The typical behaviour can be invoking the method of other class and using the member of the other class.
public class MyMainClass{

public void init(){

new OtherClass.init();

}
}',1);
insert into Answers values(21,21,'Ans) Aggregation
has a
relationship between two classes. In this relationship the object of one class is a
         member of the other class. Aggregation always insists for a direction.
public class MyMainClass{

OtherClass otherClassObj = new OtherClass();
}',1);
insert into Answers values(22,22,'Ans) To access the static method the  object of the class is not needed. The method can be access directly with the help of  ClassName. So when a program is started the jvm search for the class with main  method and calls it without creating an object of the class.',1);
insert into Answers values(23,23,'Ans) instance method belongs to the instance of a class therefore it requires an instance before it  can be invoked, whereas static method belongs to the class itself and not to any class instance so it doesn''t need an  instance to be invoked.
Instance methods use dynamic (late) binding, whereas static  methods use static (early) binding.
When the JVM invokes a class instance method, it selects the method to invoke based on the type  of the object reference, which is always known at run-time. On the other  hand, when the JVM invokes a static  method, it selects the method to invoke based on the actual class of the  object, which may only be known at compile time.',1);
insert into Answers values(24,24,'Ans) Yes, static block can throw only Runtime exception or can use a try-catch block to catch checked exception.
Typically scenario will be if JDBC connection is created in static block and it fails then exception can be caught, logged and application can exit. If System.exit() is not done, then application may continue and next time if the class is referred JVM will throw NoClassDefFounderror since the class was not loaded by the Classloader.',1);
insert into Answers values(25,25,'Ans)
1) A class is called
abstract
when it contains at least one abstract method. It can also contain n numbers of concrete method.
Interface
can contain only abstract( non implemented) methods.
2) The
abstract class
can have public,private,protect or default variables and also constants. In
interface
the variable is by default
public final
. In nutshell the interface doesnt have any variables it only has constants.
3) A class can extend only one
abstract class
but a class can implement multiple
interfaces
.
4) If an interface is implemented its compulsory to implement all of its methods but if an abstract class is extended its not compulsory to implement all methods. 
5) The problem with an interface is, if you want to add a new feature (method) in its contract, then you MUST implement those method in all of the classes which implement that interface. However, in the case of an abstract class, the method can be simply implemented in the abstract class and the same can be called by its subclass.',1);
insert into Answers values(26,26,'Ans) Consider a scenario where all Cars will have 4 tyres and other features can be different.
In this case any subclass of Car has to have 4 tyres. This is a case where abstract class will be used and a default implementaion for tyres will be provided.


public abstract class Car{

public abstract String getCarName();
public final int getNoOfTyres(){
   return 4;
}

}


Consider a scenario where Cars can have any number of tyres and other features can also be different. In this case interface will be created.


public interface Car{

public abstract String getCarName();
public abstract int getNoOfTyres();
}',1);
insert into Answers values(27,27,'Ans) There are  four different types of modifiers:

1) Private:
Accessible in the    same package
No
Accessible in    different package
No

2) Protected
Accessible in the    same package
Yes
Accessible in    different package
Yes, only if the    class extends the main class

3) Default
Accessible in the    same package
Yes
Accessible in    different package
No

4) Public
Accessible in the    same package
Yes
Accessible in    different package
Yes',1);
insert into Answers values(28,28,'Ans) The final keyword can be assigned to


Class level variable

method

class

Objects


If a final is assigned to a variable, the  variable behaves as a constant. It means that the value of variable once set cannot be  changed.
final int i=1;
i =5; // error


If a  final is assigned to a method then it cannot be  overridden in its child class.


class Parent {

final void  print(){

            System.out.println(""Inside"");
}

}

class Child extends Parent{


public final void  print(){             // error cannot  override final method

            System.out.println(""Inside"");
}
}

If a  class is made as final, then no other class can  extend it and make it as parent class. E.g. String Class.

Final  objects are instantiated only once. i.e

final Map map = new HashMap();

map.put(""key"",""value"");

map = new HashMap();  // error',1);
insert into Answers values(29,29,'Ans) This keyword is used to prevent concurrency. Synchronized keyword  can be applied to static/non-static methods or a block of code. Only one thread  at a time can access synchronized methods and if there are multiple threads trying  to access the same method then other threads have to wait for the execution of method  by one thread. Synchronized keyword  provides a lock on the object and thus prevents race condition. E.g.


public void synchronized method(){} 
public void synchronized staticmethod(){}
public void myMethod(){

            synchronized (this){             // synchronized keyword on block  of  code
            }

}',1);
insert into Answers values(30,30,'Ans) In general each thread has its own copy of variable, such that one thread is not concerned with the value of same variable in the other thread. But sometime this may not be the case. Consider a scenario in which the count variable is holding the number of times a method is called for a given class irrespective of any thread calling, in this case irrespective of thread access the count has to be increased. In this case the count variable is declared as volatile.
       The copy of volatile variable is stored in the main memory, so every time a thread access the variable even for reading purpose the local copy is updated each time from the main memory. The volatile variable also have performance issues.',1);
insert into Answers values(31,31,'Ans) If some of the properties of a class are not required to be serialized then the varaibles are marked as transient. When an object is deserialized the transient variables retains the default value depending on the type of variable declared and hence lost its original value.',1);
insert into Answers values(32,32,'Ans) Strictfp is used with variable only . It is used to restrict floating point calculations ( fp ) to ensure
portability ( platform Independent ). When this modifier is specified, the
JVM adheres to the Java specifications ( IEEE-754 floating-point
specification ) and returns the consistent value independent of the
platform. That is, if you want the answers from your code (which uses
floating point values) to be consistent in all platforms, then you need to
specify the strictfp modifier.',1);
insert into Answers values(33,33,'Ans) Static keyword can be used with the variables and methods but not with the class but there are static class. Anything declared as static is related to class and not objects.

Static variable
: Multiples objects of a class shares the same instance of a static variable.Consider the example:


public class Counter{

  private static int count=0;

 private int nonStaticcount=0;

  public void incrementCounter(){

  count++;

  nonStaticcount++;

  }


  public int getCount(){

 return count;

 }

 public int getNonStaticcount(){

 return nonStaticcount;

 }



 public static void main(String args[]){


  Counter countObj1 = new Counter();

 Counter countObj2 = new Counter();

  countObj1.incrementCounter();

  countObj1.incrementCounter();

  System.out.println(""Static count for Obj1: ""+countObj1.getCount());

  System.out.println(""NonStatic count for Obj1: ""+countObj1.getNonStaticcount());

  System.out.println(""Static count for Obj2: ""+countObj2.getCount())

  System.out.println(""NonStatic count for Obj2: ""+countObj2.getNonStaticcount())

  }




Output

Static count for Obj1: 2

NonStatic count for Obj1: 2

Static count for Obj2: 2

NonStatic count for Obj2: 0


In the above program obj1 and obj2 share the same instance of static variable count hence if the value is incremented by
one object , the incremented value will be reflected across the other objects.',1);
insert into Answers values(34,34,'Ans)A method defined as static is called static method. A static method can be accessed without creating the objects. Just by
using the Class name the method can be accessed.

Static method can only access static variables and not local or global
non-static variables.
For eg:

public class Test{
public static void printMe(){
System.out.println(""Hello World"");
}
}
public class MainClass{
 public static void main(String args[]){
  Test.printMe()

    }
 }
OutPut:
Hello World


Also static method can call only static methods and not non static methods. But non-static methods can call static mehtods.',1);
insert into Answers values(35,35,'Ans) A static method cannot access non static variables or methods because static methods doesnt need the object to be 
accessed. So if a static method has non static variables or non static methods which has instantiated variables
they will no be intialized since the object is not created and this could result in an error.',1);
insert into Answers values(36,36,'Ans) A class cannot be declared static. But a class can be said a static class if all the variables and methods of the class
are static and the constructor is private. Making the constructor private will prevent the class to be
instantiated. So the only possibility to access is using Class name only',1);
insert into Answers values(37,37,'Ans) Throw keyword is used to throw the exception manually. It is mainly used when the program fails to satisfy the given condition and it wants to warn the application.The exception thrown should be subclass of Throwable.

  public void parent(){
  try{
   child();
  }catch(MyCustomException e){ }
  }

  public void child{
  String iAmMandatory=null;
    if(iAmMandatory == null){
    throw (new MyCustomException(""Throwing exception using throw keyword"");
   }
  }',1);
insert into Answers values(38,38,'Ans)
1) Synchronization - ArrayList is not thread-safe whereas Vector is thread-safe. In Vector class each method like add(), get(int i) is surrounded with a synchronized block and thus making Vector class thread-safe.

2) Data growth - Internally, both the ArrayList and Vector hold onto their contents using an Array. When an element is inserted into an ArrayList or a Vector, the object will need to expand its internal array if it runs out of room. A Vector defaults to doubling the size of its array, while the ArrayList increases its array size by 50 percent.',1);
insert into Answers values(39,39,'Ans) Arraylist can be synchronized using:



Collection.synchronizedList(List list)

Other collections can be synchronized:

Collection.synchronizedMap(Map map)

Collection.synchronizedCollection(Collection c)',1);
insert into Answers values(40,40,'Ans) 1) Implement Comparable interface for the Employee class and override the compareTo(Object obj) method in which compare the employeeID


2) Now call Collections.sort() method and pass list as an argument.

Now consider that Employee class is a jar file.

1) Since Comparable interface cannot be implemented, create Comparator and override the compare(Object obj, Object obj1) method .

2) Call Collections.sort() on the list and pass comparator as an argument.',1);
insert into Answers values(41,41,'Ans)
       Both collections implements Map. Both collections store value as key-value pairs.
      The key differences between the two are


1. Hashmap is not synchronized in nature but hshtable is.

2. Another difference is that iterator in the HashMap is fail-safe while the enumerator for the Hashtable isn''t.

Fail-safe
- if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator''s own remove method, the iterator will throw a ConcurrentModificationException??

3.  HashMap permits null values and only one null key, while Hashtable doesn''t allow key or value as null.',1);
insert into Answers values(42,42,'Ans)
There are three classes that implement List interface:
1)
ArrayList
: It is a resizable array implementation. The size of the ArrayList can be increased dynamically also operations like add,remove and get can be formed once the object is created. It also ensures that the data is retrieved in the manner it was stored. The ArrayList is not thread-safe.
2)
Vector
: It  is thread-safe implementation of ArrayList. The methods are wrapped around a synchronized block.
3)
LinkedList
: the LinkedList also implements Queue interface and provide FIFO(First In First Out) operation for add operation. It is faster if than ArrayList if it performs insertion and deletion of elements from  the middle of a list.',1);
insert into Answers values(43,43,'Ans)
 A Set is a collection that contains no duplicate elements. More formally, sets contain 
no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element.
HashSet,SortedSet and TreeSet
are the commnly used class which implements Set interface.

SortedSet
- It is an interface which extends Set. A the name suggest , the interface allows the data to be 
iterated in the ascending order or sorted on the basis of Comparator or Comparable interface. All elements
inserted into the interface must implement Comparable or Comparator interface.

TreeSet
- It is the implementation of SortedSet interface.This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains).
The class is not synchronized.

HashSet:
This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.
This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets',1);
insert into Answers values(44,44,'Ans)
1) List can contain duplicate values but Set doesnt allow. Set allows only to unique elements.
2) List allows retrieval of data to be in same order in the way it is inserted but Set doesnt ensures the sequence in which data can be retrieved.(Except HashSet)',1);
insert into Answers values(45,45,'Ans)
      Arrays       are created of fix size whereas ArrayList is of not fix size. It means       that once array is declared as :



int [] intArray= new int[6];

intArray[7]   // will give ArraysOutOfBoundException.




Also the size of  array cannot be incremented or decremented. But with arrayList the size is  variable.


Once the array is created elements cannot be added or deleted from it. But with                 ArrayList the elements can be added and deleted at runtime.


List list = new ArrayList();
list.add(1);
list.add(3);
list.remove(0) //  will remove the element from the 1st location.


ArrayList is one dimensional but array can be multidimensional.

            int[][][] intArray= new  int[3][2][1];   // 3 dimensional array    

To create an array the size should be known or initalized to some value. If not initialized carefully there could me memory wastage. But arrayList is all about dynamic creation and there is no wastage of memory.',1);
insert into Answers values(46,46,'Ans)  Adding new elements is pretty fast for either  type of list. For the ArrayList, doing  random  lookup using ""get"" is fast, but for LinkedList, it''s slow. It''s slow  because there''s no efficient way to index into the middle of a linked list.  When removing elements, using ArrayList is slow. This is because all remaining  elements in the underlying array of Object instances must be shifted down for  each remove operation. But here LinkedList is fast, because deletion can be  done simply by changing a couple of links. So an ArrayList works best for cases  where you''re doing random access on the list, and a LinkedList works better if  you''re doing a lot of editing in the middle of the list.

Source :
Read More - from java.sun',1);
insert into Answers values(47,47,'Ans) It can be done in two ways, using for loop or using iterator of ArrayList. The first option is faster than using iterator. Because value stored in arraylist is indexed access. So while accessing the value is accessed directly as per the index.',1);
insert into Answers values(48,48,'Ans) For loop does not allow the updation in the array(add or remove operation) inside the loop whereas Iterator does.
      Also Iterator can be used where there is no clue what type of collections will be used because all collections have iterator.',1);
insert into Answers values(49,49,'Ans) It depends on the different scenario one is working on:
1) If the objects in the hashMap are same then there is no point in having different hashmap as the traverse time in a hashmap is invariant to the size
             of the Map.
2) If the objects are of different type like one of Person class , other of Animal class etc then also one can have single hashmap but different hashmap 
             would score over it as it would have better readability.',1);
insert into Answers values(50,50,'Ans) It is preferred because:

If later on code needs to be changed from  ArrayList to Vector then only at the declaration place we can do that.

The most important one - If a function is  declared such that it takes list. E.g void showDetails(List list);
When the parameter is declared as List  to  the function it can be called by passing any subclass of List like ArrayList,Vector,LinkedList making the function more flexible',1);
insert into Answers values(51,51,'Ans) Index based access allow access of the element directly on the basis of index. The cursor of the datastructure can directly goto the ''n'' location and get the element. It doesnot traverse through n-1 elements.

In Iterator based access, the cursor has to traverse through each element to get the desired element.So to reach the ''n''th element it need to traverse through n-1 elements.

Insertion,updation or deletion will be faster for iterator based access if the operations are performed on elements present in between the datastructure.

Insertion,updation or deletion will be faster for index based access if the operations are performed on elements present at last of the datastructure.

Traversal or search in index based datastructure is faster.

ArrayList is index access and LinkedList is iterator access.',1);
insert into Answers values(52,52,'Ans) To sort the elements of the List in the reverse natural order of the strings, get a reverse Comparator from the Collections class with reverseOrder(). Then,  pass the reverse Comparator to the sort() method.



List list = new ArrayList();

Comparator comp = Collections.reverseOrder();

Collections.sort(list, comp)',1);
insert into Answers values(53,53,'Ans) A null element can be added only if the set contains one element because when a second element is added then as per set defination a check is made to check duplicate value and comparison  with null element will throw NullPointerException.
HashSet is based on hashMap and can contain null element.',1);
insert into Answers values(54,54,'Ans) using Collections.sort(list, String.CASE_INSENSITIVE_ORDER);',1);
insert into Answers values(55,55,'Ans) A list implemenation can be made read only using
Collections.unmodifiableList(list)
. This method returns a new list. If a user tries to perform add operation on the new list; UnSupportedOperationException is thrown.',1);
insert into Answers values(56,56,'Ans) A concurrentHashMap is thread-safe implementation of Map interface. In this class put and remove method are synchronized but not get method. This class is different from Hashtable in terms of locking; it means that hashtable use object level lock but this class uses bucket level lock thus having better performance.',1);
insert into Answers values(57,57,'Ans) LinkedList.',1);
insert into Answers values(58,58,'Ans) HashSet implements hashmap internally to store the data. The data passed to hashset is stored as key in hashmap with null as value.',1);
insert into Answers values(59,59,'Ans) HashMap is fastest, ConcurrentHashMap,Collections.synchronizedMap,HashTable.',1);
insert into Answers values(60,60,'Ans) The IdentityHashMap uses == for equality checking instead of equals(). This can be used for both performance reasons, if you know that two different elements will never be equals and for preventing spoofing, where an object tries to imitate another.',1);
insert into Answers values(61,61,'Ans) The exception is said to be thrown whenever an exceptional event occurs in java which signals that something is not correct with the code written and may give unexpected result. An exceptional event is a occurrence of condition which alters the normal    program flow. Exceptional handler is the code that does something about the exception.',1);
insert into Answers values(62,62,'Ans)All the exceptions are subclasses of java.lang.Exception',1);
insert into Answers values(63,63,'Ans)When an exception occurs the  execution of the program is transferred to an appropriate exception handler.The try-catch-finally block is used to handle the exception.
The code in which the  exception may occur is enclosed in a try block, also called as a guarded region.
The catch clause matches a  specific exception to a block of code which handles that exception.
And the clean up code which  needs to be executed no matter the exception occurs or not is put inside the finally block',1);
insert into Answers values(64,64,'Ans) The hierarchy is as follows:



Throwable is a parent class off all Exception classes. They are two types of Exceptions: Checked exceptions and UncheckedExceptions. Both type of exceptions extends Exception class.',1);
insert into Answers values(65,65,'Ans) Runtime exceptions represent problems that are the result of  a programming problem. Such problems include arithmetic exceptions, such as  dividing by zero; pointer exceptions, such as trying to access an object  through a null reference; and indexing exceptions, such as attempting to access  an array element through an index that is too large or too small. Runtime  exceptions need not be explicitly caught in try catch block as it can occur  anywhere in a program, and in a typical one they can be very numerous. Having  to add runtime exceptions in every method declaration would reduce a program''s  clarity. Thus, the compiler does not require that you catch or specify runtime  exceptions (although you can). The solution to rectify is to correct the  programming logic where the exception has occurred or provide a check.',1);
insert into Answers values(66,66,'Ans) Checked exception are the exceptions which forces the programmer to catch them explicitly in try-catch block. It is a subClass of Exception. Example: IOException.',1);
insert into Answers values(67,67,'Ans) An error is an  irrecoverable condition occurring at runtime. Such as OutOfMemory  error. These JVM errors and you can not repair them at runtime.Though error can be caught in catch block but the execution of application will come to a halt and is not recoverable.

While  exceptions are conditions that occur because of bad input etc. e.g.  FileNotFoundException will be thrown if the specified file does not  exist. Or a NullPointerException will take place if you try using a  null reference. In most of the cases it is possible to recover from an  exception (probably by giving user a feedback for entering proper  values etc.)',1);
insert into Answers values(68,68,'Ans) A ClassNotFoundException is thrown when the reported class is not found by the ClassLoader in the CLASSPATH. It could also mean that the class in question is trying to be loaded from another class which was loaded in a parent classloader and hence the class from the child classloader is not visible.

Consider if NoClassDefFoundError occurs which is something like

java.lang.NoClassDefFoundError

src/com/TestClass

does not mean that the TestClass class is not in the CLASSPATH. It means that the class TestClass was found by the ClassLoader however when trying to load the class, it ran into an error reading the class definition. This typically happens when the class in question has static blocks or members which use a Class that''s not found by the ClassLoader. So to find the culprit, view the source of the class in question (TestClass in this case) and look for code using static blocks or static members.',1);
insert into Answers values(69,69,'Ans) Throw keyword is used to throw the exception manually. It is mainly used when the program fails to satisfy the given condition and it wants to warn the application.The exception thrown should be subclass of Throwable.
  public void parent(){
  try{
   child();
  }catch(MyCustomException e){ }
  }

  public void child{
  String iAmMandatory=null;
    if(iAmMandatory == null){
    throw (new MyCustomException(""Throwing exception using throw keyword"");
   }
  }',1);
insert into Answers values(70,70,'Ans) If the function is not capable of handling the exception then it can ask the calling method to handle it by simply putting the
throws clause
at the function declaration.

  public void parent(){
  try{
   child();
  }catch(MyCustomException e){ }
  }

  public void child throws MyCustomException{
     //put some logic so that the exception occurs.
  }',1);
insert into Answers values(71,71,'Ans)


1)  try{


//lines of code that may throw an exception


}catch(Exception e){


//lines of code to handle the exception thrown in try block


}finally{


//the clean code which is executed always no matter the exception occurs or not.


}




2 try{

}finally{}

3 try{

}catch(Exception e){

//lines of code to handle the exception thrown in try block

}




The  catch blocks must always follow the try block. If there are more than one catch  blocks they all must follow each other without any block in between.  The finally block must follow  the catch block if one is present or if the catch block is absent the finally  block must follow the try block.',1);
insert into Answers values(72,72,'Ans) To create you own exception extend the Exception class or any of its subclasses.

e.g.

1 class New1Exception extends Exception { } // this will create Checked Exception

2 class NewException extends IOExcpetion { } // this will create Checked exception

3 class NewException extends NullPonterExcpetion { } // this will create UnChecked exception',1);
insert into Answers values(73,73,'Ans) If an application can reasonably be expected   to recover from an exception, make it a checked exception. If an   application cannot do anything to recover from the exception, make   it an unchecked exception.',1);
insert into Answers values(74,74,'Ans) The StackOverFlowError is an Error Object thorwn by the Runtime System  when it Encounters that your application/code has ran out of the memory. It may occur in case of recursive methods or a large amount of data is fetched from the server and stored in some object. This error is generated by JVM.

e.g.
    void swap(){


swap();


}',1);
insert into Answers values(75,75,'Ans) No. Once the control jumps to the catch block it never returns to the try block but it goes  to finally block(if present).',1);
insert into Answers values(76,76,'Ans) The code is put in a finally block because irrespective of try or catch block execution the control will flow to finally block. Typically finally block contains release of connections, closing of result set etc.',1);
insert into Answers values(77,77,'Ans) NO. This will result in a compilation error.
   The try block must be followed by a catch or a finally block.
   It is legal to omit the either catch or the finally block but not both.
e.g.  The following code is illegal.


try{
int i =0;
}
int a = 2;
System.out.println(""a =  ""+a);',1);
insert into Answers values(78,78,'Ans) No. There should not be any line of code present between the try and the catch/finally block.
   e.g.  The following code is wrong.



try{}
String str = ""ABC"";
System.out.println(""str  = ""+str);
catch(Exception e){}',1);
insert into Answers values(79,79,'Ans) If the exception is not caught by any of the method in the methods stack till you get to the main() method, the main method throws that exception and the JVM halts its execution.',1);
insert into Answers values(80,80,'Ans) All the exceptions inherit a method printStackTrace() from the Throwable class. This method prints the stack trace from where the exception occurred.
    It prints the most recently entered method first and continues down, printing the name of each method as it works its way down the call stack from the top.',1);
insert into Answers values(81,81,'Ans)Yes. If the exception class specified in the catch clause has
      subclasses, any exception object that is a subclass of the specified Exception class will be caught by that single catch block.

E.g..



try {

// Some code here that can throw an IOException

}

catch (IOException e) {


e.printStackTrace();


}



The catch block above will catch IOException and all its subclasses e.g. FileNotFoundException etc.',1);
insert into Answers values(82,82,'Ans) You can write a single catch block to handle all the exceptions thrown during the program execution as follows :



try {


// code that can throw exception of any possible type


}catch (Exception e) {


e.printStackTrace();


}



If you use the Superclass Exception in the catch block then you will not get the valuable information about each of the exception thrown during the execution, though you can find out the class of the exception occurred. Also it will reduce the readability of the code as the programmer will not understand what is the exact reason for putting the try-catch block.',1);
insert into Answers values(83,83,'Ans) Exception matching is the process by which the the jvm finds out the matching catch block for the exception thrown from the list of catch blocks. When an exception is thrown, Java will try to find by looking at the available
     catch clauses in the top down manner.
     If it doesn''t find one, it will search for a handler for a supertype of the exception. If it does not
     find a catch clause that matches a supertype for the exception, then the exception
     is propagated down the call stack. This process is called exception matching.',1);
insert into Answers values(84,84,'Ans) Compilation fails.
     The catch block for handling the most specific exceptions
     must always be placed above the catch block written to handle the more general exceptions.

e.g. The code below will not compile.



1 try {

// code that can throw IOException or its subtypes

} catch (IOException e) {

// handles IOExceptions and its subtypes

} catch (FileNotFoundException ex) {

// handle FileNotFoundException only

}



The code below will compile successfully :-

try {
// code that can throw IOException or its subtypes
} catch (FileNotFoundException ex)  {
// handles IOExceptions and its subtypes
} catch (IOException e){
// handle FileNotFoundException only
}',1);
insert into Answers values(85,85,'Ans) No. If the exceptions are siblings in the Exception class''s hierarchy i.e. If one Exception class is not a subtype or supertype of the other, then the order in which
    their handlers(catch clauses) are placed does not matter.',1);
insert into Answers values(86,86,'Ans) If a method does not throw an checked  Exception directly but calls a method that throws an exception then the calling method must handle the throw exception or declare the exception in its throws clause. If the calling method does not handle and declares the exception, the exceptions is passed to the next method in the method stack. This is called as ducking the exception down the method stack.

e.g. The code below will not compile as the getCar() method has not declared the CarNotFoundException which is thrown by the getColor () method.



void getCar() {


getColor();


}

void getColor () {


throw new CarNotFoundException();


}



Fix for the above code is



void getCar() throws CarNotFoundException {


getColor();


}

void getColor () {


throw new CarNotFoundException();


}',1);
insert into Answers values(87,87,'Ans) Yes you can leave the catch block without writing any actual code to handle the exception caught.

e.g. The code below is legal but not appropriate, as in this case you will nt get any information about the exception thrown.


try{

//code that may throw the FileNotFoundException

}catch(FileNotFound eFnf){

//no code to handle the FileNotFound exception

}

 ',1);
insert into Answers values(88,88,'Ans)
Heap',1);
insert into Answers values(89,89,'Ans)
Garbage collector frees the memory occupied by the unreachable objects during the java program by deleting these unreachable objects.
It ensures that the available memory will be used efficiently, but does not guarantee that there will be sufficient memory for the program to run.',1);
insert into Answers values(90,90,'Ans)
Yes GC is a dameon thread. A dameon thread runs behind the application. It is started by JVM. The thread stops when all non-dameon threads stop.',1);
insert into Answers values(91,91,'Ans)
The JVM controls the Garbage Collector; it decides when to run the Garbage Collector. JVM runs the Garbage Collector when it realizes that the memory is running low, but this behavior of jvm can not be guaranteed.
One can request the Garbage Collection to happen from within the java program but there is no guarantee that this request will be taken care of by jvm.',1);
insert into Answers values(92,92,'Ans)
An object becomes eligible for Garbage Collection when no live thread can access it.',1);
insert into Answers values(93,93,'Ans)

1.
Set all available object references to null
once the purpose of creating the object is served :

public class GarbageCollnTest1 {

      public static void main (String [] args){

String str = ""Set the object ref to null"";
//String object referenced by variable str is not eligible for GC yet
str = null;
/*String object referenced by variable str becomes eligible for GC */

     }

}


2.
Make the reference variable to refer to another object
:
Decouple the reference variable from the object and set it refer to another object, so the object which it was referring to before reassigning is eligible for Garbage Collection.


publc class GarbageCollnTest2 {

     public static void main(String [] args){

String str1 = ""Garbage collected after use"";
String str2 = ""Another String"";
System.out.println(str1);
//String object referred by str1 is not eligible for GC yet
str1 = str2;
/* Now the str1 variable referes to the String object ""Another String"" and the object ""Garbage collected after use"" is not referred by any variable and hence is eligible for GC */

      }

}


3)
Creating Islands of Isolation
: 
If  you have two instance reference variables which are referring to the instances of the same class, and these two reference variables refer to each other and the objects referred by these reference variables do not have any other valid reference then these two objects are said to form an Island of Isolation and are eligible for Garbage Collection.

public class GCTest3 {
GCTest3 g;

     public static void main(String [] str){

GCTest3 gc1 = new GCTest3();
GCTest3 gc2 = new GCTest3();
gc1.g = gc2; //gc1 refers to gc2
gc2.g = gc1; //gc2 refers to gc1
gc1 = null;
gc2 = null;
//gc1 and gc2 refer to each other and have no other valid //references
//gc1 and gc2 form Island of Isolation
//gc1 and gc2 are eligible for Garbage collection here

    }

}',1);
insert into Answers values(94,94,'Ans) No. The Garbage Collection can not be forced, though there are few ways by which it can be requested there is no guarantee that these requests will be taken care of by JVM.',1);
insert into Answers values(95,95,'Ans) There are two ways in which we can request the jvm to execute the Garbage Collection.

1) The methods to perform the garbage collections are present in the Runtime class provided by java. The Runtime class is a Singleton for each java main program.
The method getRuntime() returns a singleton instance of the Runtime class. The method gc() can be invoked using this instance of Runtime to request the garbage collection.


2) Call the System class System.gc() method which will request the jvm to perform GC.',1);
insert into Answers values(96,96,'Ans) The finalize() method should be overridden for an object to include the clean up code or to dispose of the system resources that should to be done before the object is garbage collected.',1);
insert into Answers values(97,97,'Ans) No',1);
insert into Answers values(98,98,'Ans) Only once.',1);
insert into Answers values(99,99,'Ans) The exception will be ignored and the garbage collection (finalization) of that object terminates.',1);
insert into Answers values(100,100,'Ans) Garbage collection can be invoked using
System.gc() or Runtime.getRuntime().gc()
.',1);
insert into Answers values(101,101,'Ans) In Java, "thread" means two different things:

An instance of class java.lang.Thread.

A thread of execution.
An instance of Thread is just an object. Like any other object in Java, it has variables and methods, and lives and dies on the heap. But a thread of execution is an individual process (a "lightweight" process) that has its own call stack. In Java, there is one thread per call stack-or, to think of it in reverse, one call stack per thread. Even if you don"t create any new threads in your program, threads are back there running.
The main() method, that starts the whole ball rolling, runs in one thread, called (surprisingly) the main thread. If you looked at the main call stack (and you can, any time you get a stack trace from something that happens after main begins, but not within another thread), you''d see that main() is the first method on the stack- the method at the bottom. But as soon as you create a new thread, a new stack materializes and methods called from that thread run in a call stack that"s separate from the main() call stack.',1);
insert into Answers values(102,102,'Ans)
Differences between threads and processes are:-
1. Threads share the address space of the process that  created it; processes have their own address.

2. Threads have direct access to the data segment of its process;  processes have their own copy of the data segment of the parent process.

3. Threads can directly communicate with other threads of its  process; processes must use interprocess communication to communicate with  sibling processes.

4. Threads have almost no overhead; processes have considerable  overhead.

5. New threads are easily created; new processes require duplication  of the parent process.

6. Threads can exercise considerable control over threads of  the same process; processes can only exercise control over child processes.

7. Changes to the main thread (cancellation, priority change,  etc.) may affect the behavior of the other threads of the process; changes to  the parent process do not affect child processes.',1);
insert into Answers values(103,103,'Ans)
 
Threads support  concurrent operations. For example,
 - Multiple requests by a client on  a server can be handled as an individual client thread.
 - Long computations or high-latency  disk and network operations can be handled in the background without disturbing  foreground computations or screen updates.
Threads often result in simpler programs.
- In sequential programming,  updating multiple displays normally requires a big while-loop that performs  small parts of each display update. Unfortunately, this loop basically  simulates an operating system scheduler. In Java, each view can be assigned a  thread to provide continuous updates.
- Programs that need to respond to  user-initiated events can set up service routines to handle the events without  having to insert code in the main routine to look for these events.
Threads provide a high degree of control.
- Imagine launching a complex  computation that occasionally takes longer than is satisfactory. A  "watchdog" thread can be activated that will "kill" the computation  if it becomes costly, perhaps in favor of an alternate, approximate solution. Note  that sequential programs must muddy the computation with termination code,  whereas, a Java program can use thread control to non-intrusively supervise any  operation.
Threaded applications exploit parallelism.
- A computer with multiple CPUs can  literally execute multiple threads on different functional units without having  to simulating multi-tasking ("time sharing").
- On some computers, one CPU  handles the display while another handles computations or database accesses,  thus, providing extremely fast user interface response times.',1);
insert into Answers values(104,104,'Ans) There are two ways to create a new thread.

1)Extend the Thread class and override the run() method in your class. Create an instance of the subclass and invoke the start() method on it, which will create a new thread of execution. e.g.

public class NewThread extends Thread{

public void run(){ 
// the code that has to be executed in a separate new thread goes here
} 
public static void main(String [] args){ 
NewThread c = new NewThread(); 
c.start(); 
}

}

2)Implements the Runnable interface.The class will have to implement the run() method in the Runnable interface. Create an instance of this class. Pass the reference of this instance to the Thread constructor a new thread of execution will be created. e.g. class

public class NewThread implements Runnable{

public void run(){ 
// the code that has to be executed in a separate new thread goes here
} 
public static void main(String [] args){ 
NewThread c = new NewThread(); 
Thread t = new Thread(c);
t.start();
}

}',1);
insert into Answers values(105,105,'Ans) The different states of threads are as follows:

1) New – When a thread is instantiated it is in New state until the start() method is called on the thread instance. In this state the thread is not considered to be alive. 
2) Runnable – The thread enters into this state after the start method is called in the thread instance. The thread may enter into the Runnable state from Running state. In this state the thread is considered to be alive. 
3) Running – When the thread scheduler picks up the thread from the Runnable thread’s pool, the thread starts running and the thread is said to be in Running state.
 4) Waiting/Blocked/Sleeping – In these states the thread is said to be alive but not runnable. The thread switches to this state because of reasons like wait method called or sleep method has been called on the running thread or thread might be waiting for some i/o resource so blocked. 5)      Dead – When the thread finishes its execution i.e. the run() method execution completes, it is said to be in dead state. A dead state can not be started again. If a start() method is invoked on a dead thread a runtime exception will occur.',1);
insert into Answers values(106,106,'Ans) synchronized keyword can be applied to static/non-static methods or a block of code. Only one thread at a time can access synchronized methods and if there are multiple threads trying to access the same method then other threads have to wait for the execution of method by one thread. Synchronized keyword provides a lock on the object and thus prevents race condition. E.g.

public void synchronized method(){}  
public void synchronized staticmethod(){}
public void myMethod(){

            synchronized (this){             // synchronized keyword on block of  code
            }

}',1);
insert into Answers values(107,107,'Ans) When a synch non static method is called a lock is obtained on the object. When a synch static method is called a lock is obtained on the class and not on the object. The lock on the object and the lock on the class don''t interfere with each other. It means, a thread accessing a synch non static method, then the other thread can access the synch static method at the same time but can''t access the synch non static method.',1);
insert into Answers values(108,108,'Ans) In general each thread has its own copy of variable, such that one thread is not concerned with the value of same variable in the other thread. But sometime this may not be the case. Consider a scenario in which the count variable is holding the number of times a method is called for a given class irrespective of any thread calling, in this case irrespective of thread access the count has to be increased so the count variable is declared as volatile. The copy of volatile variable is stored in the main memory, so every time a thread access the variable even for reading purpose the local copy is updated each time from the main memory. The volatile variable also have performance issues.',1);
insert into Answers values(109,109,'Ans)  yield() allows the current the thread to release its lock from the object and scheduler gives the lock of the object to the other thread with same priority.
         sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn’t release the lock.',1);
insert into Answers values(110,110,'Ans)

1) wait() is a method of Object class. sleep() is a method of Object class.

2) sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn’t release the lock. wait() allows thread to release the lock and goes to suspended state. The thread is only active when a notify() or notifAll() method is called for the same object.',1);
insert into Answers values(111,111,'Ans) notify( ) wakes up the first thread that called wait( ) on the same object. 
notifyAll( ) wakes up all the threads that called wait( ) on the same object. The 
highest priority thread will run first.',1);
insert into Answers values(112,112,'Ans) If a thread has been instantiated but not started its is said to be in new state. Unless until a start() method is invoked on the instance of the thread, it will not said to be alive. If you do not call a start() method on the newly created thread instance thread is not considered to be alive. If the start() method is not invoked and the run() method is directly called on the Thread instance, the code inside the run() method will not run in a separate new thread but it will start running in the existing thread.',1);
insert into Answers values(113,113,'Ans) A new thread of execution with a new call stack starts. The state of thread changes from new to runnable. When the thread gets chance to execute its target run() method starts to run.',1);
insert into Answers values(114,114,'Ans) When a code running in a thread creates a new thread object , the priority of the new thread is set equal to the priority of the thread which has created it.',1);
insert into Answers values(115,115,'Ans) When jvm starts up the thread executing main method is started.',1);
insert into Answers values(116,116,'Ans) Daemon thread are service provider threads run in the background,these not used to run the application code generally.When all user threads(non-daemon threads) complete their execution the jvm exit the application whatever may be the state of the daemon threads. Jvm does not wait for the daemon threads to complete their execution if all user threads have completed their execution.

To create Daemon thread set the daemon value of Thread using setDaemon(boolean value) method. By default all the threads created by user are user thread. To check whether a thread is a Daemon thread or a user thread use isDaemon() method.

Example of the Daemon thread is the Garbage Collector run by jvm to reclaim the unused memory by the application. The Garbage collector code runs in a Daemon thread which terminates as all the user threads are done with their execution.',1);
insert into Answers values(117,117,'Ans) Thread()
 Thread(Runnable target)
Thread(Runnable target, String name)
Thread(String name)',1);
insert into Answers values(118,118,'Ans) No. Only methods can be synchronized.',1);
insert into Answers values(119,119,'Ans) Each object has only one lock.',1);
insert into Answers values(120,120,'Ans) Yes a class can have both synchronized and non-synchronized methods.',1);
insert into Answers values(121,121,'Ans) Yes. If a class has a synchronised and non-synchronised methods, multiple threads can access the non-synchronised methods.',1);
insert into Answers values(122,122,'Ans) Yes when a thread goes to sleep it does not release the lock.',1);
insert into Answers values(123,123,'Ans) Yes. A thread can hold multiple locks at the same time. Once a thread acquires a lock and enters into the synchronized method / block, it may  call another synchronized method and acquire a lock on another object.',1);
insert into Answers values(124,124,'Ans) Yes. Once a thread acquires a lock in some object, it may call any other synchronized method of that same object using the lock that it already holds.',1);
insert into Answers values(125,125,'Ans) Yes. As static methods are class methods and have only one copy of static data for the class, only one lock for the entire class is required. Every class in java is represented by java.lang.Class instance. The lock on this instance is used to synchronize the static methods.',1);
insert into Answers values(126,126,'Ans) No. The static synchronized methods of the same class always block each other as only one lock per class exists.
 So no two static synchronized methods can execute at the same time.',1);
insert into Answers values(127,127,'Ans)No As the thread executing the static synchronized method holds a lock on the class and the thread executing the non-satic synchronized method holds the lock on the object on which the method has been called, these two locks are different and these threads do not block each other.',1);
insert into Answers values(128,128,'Ans) No. Only a thread can be started only once in its lifetime.
      If you try starting a thread which has been already started once an IllegalThreadStateException is thrown, which is a runtime exception.
     A thread in runnable state or a dead thread can not be restarted.',1);
insert into Answers values(129,129,'Ans) When a locked object tries to access a locked object which is trying to access the first locked object.
      When the threads are waiting for each other to release the lock on a particular object, deadlock occurs .',1);
insert into Answers values(130,130,'Ans) If a class is made to extend the thread class to have a multithreaded application then this subclass of Thread can not extend any other class and the required application will have to be added to this class as it can not be inherited from any other class.
      If a class is made to implement Runnable interface, then the class can extend other class or implement other interface.',1);
insert into Answers values(131,131,'Ans) Yes the start() method can be overridden. But it should not be overridden as it’s implementation in thread class has the code to create a new executable thread and is specialised.',1);
insert into Answers values(132,132,'Ans) The methods are as follows:


public static void sleep(long millis) throws InterruptedException

public static void yield()

public final void join() throws  InterruptedException

public final void setPriority(int priority)

public final void wait() throws InterruptedException

public final void notify()

public final void notifyAll()',1);
insert into Answers values(133,133,'Ans) The methods are:


public final void wait() throws Interrupted exception

public final void notify()

public final void notifyAll()',1);
insert into Answers values(134,134,'Ans) Methods which are mainly used :


public static void sleep(long  millis) throws Interrupted exception

public static void yield()  public final void join() throws Interrupted exception

public final void setPriority(int  priority)

public void start()

public void interrupt()

public final void join()

public void run()

public void resume()',1);
insert into Answers values(135,135,'Ans) Following are the methods.


notify()

join()

sleep()

yield()',1);
insert into Answers values(136,136,'Ans) wait()',1);
insert into Answers values(137,137,'Ans) Yes each thread has its own call stack. For eg

Thread t1 = new Thread();
Thread t2 = new Thread();
Thread t3 = t1;

In the above example t1 and t3 will have the same stack and t2 will have its own independent stack.',1);
insert into Answers values(138,138,'Ans) In a multi-threaded environment thread starvation occurs if a low priority thread is not able to run or get a lock on the resoruce because of presence of many high priority threads. This is mainly possible by setting thread priorities inappropriately.',1);
insert into Answers values(139,139,'Ans) Inner class is a class defined inside other class and act like a  member of the enclosing class.',1);
insert into Answers values(140,140,'Ans) There are two main types of inner classes -


Static member class

Inner class

Member class

Anonymous class

Local class',1);
insert into Answers values(141,141,'Ans) A static member class behaves much like an ordinary  top-level class, except that it can access the static members of the class that  contains it. The static nested class can be accessed as the other static  members of the enclosing class without having an instance of the outer class.  The static class can contain non-static and static members and methods.

public class InnerClass {

      static class StaticInner {

            static int
i
= 9;
            int no = 6;

            private void method() {}

            public void method1() {}

            static void method2() {}

            final void method3() {}

      }
}

      The  static inner class can be accessed from Outer Class in the following manner:
InnerClass.StaticInner staticObj= new InnerClass. StaticInner ();

No outer class instance is required to  instantiate the nested static class because the static class is a static member  of the enclosing class.',1);
insert into Answers values(142,142,'Ans) The different type of static inner classes are:
  Non - static inner  classes - classes associated with the object of the enclosing class.
Member class
-  Classes declared outside a function (hence a "member") and not  declared "static".
The member class can be declared as public, private,  protected, final and abstract. E.g.


public class InnerClass {


class MemberClass {



public void  method1() { }
}
}


Method local class
- The inner class declared inside the method is called method local inner  class. Method local inner class can only be declared as final or abstract.        Method local class can only access global variables or  method local variables if declared as final


public class InnerClass {

int i = 9;

public void method1() {

final int k = 6;
class MethodLocal {
MethodLocal() {
System.out.println(k  + i);
}
}
}
}



Anonymous inner  class
- These are local classes which are automatically declared and  instantiated in the middle of an expression.  Also, like local classes, anonymous classes  cannot be public, private, protected, or static. They can specify arguments to  the constructor of the superclass, but cannot otherwise have a constructor. They  can implement only one interface or extend a class.
Anonymous class cannot define any static fields, methods,  or classes, except for static final constants.
Also, like local classes, anonymous classes cannot be  public, private, protected, or static

Some examples:


public class MyFrame extends JFrame {

JButton btn = new JButton();
MyFrame() {
btn.addActionListener(new  ActionListener() {
public void  actionPerformed(ActionEvent e) {
}
});
}
}

Anonymous class  used with comparator

List<Parent> l = new ArrayList<Parent>();
l.add(new Parent(2));
l.add(new Parent(3));
Collections.sort(l, new Comparator() {
public int compare(Object o1,  Object o2) {
Parent prt1 = (Parent) o1;
Parent prt2 = (Parent) o2;



if (prt1.getAge() >  prt2.getAge()) {


return -1;
}else if(prt1.getAge()<prt2.getAge())  {


return 1;
} else {


return 0;
}
}
});',1);
insert into Answers values(143,143,'Ans) No .',1);
insert into Answers values(144,144,'Ans) The embedding of inner class into the outer class in the
        case when the inner class is to be used only by one class i.e.
        the outer class makes the package more streamlined. Nesting the
        inner class code where it is used (inside the outer class) makes
        the code more readable and maintainable.

The inner class shares a special relationship with the outer
        class i.e. the inner class has access to all members of the outer
        class and still have its own type is the main advantages of Inner
        class. Advantage of inner class is that they can be hidden from
        the other classes in the same package and still have the access
        to all the members (private also) of the enclosing class. So the
        outer class members which are going to be used by the inner class
        can be made private and the inner class members can be hidden
        from the classes in the same package. This increases the level of
        encapsulation.

If a class A is written requires another class B for its own use,
        there are two ways to do this. One way is to write a separate
        class B or to write an inner class B inside class A. Advantage of
        writing the inner class B in the class A is you can avoid having
        a separate class. Inner classes are best used in the event
        handling mechanism and to implement the helper classes. The
        advantage of using inner class for event handling mechanism is
        that the use of if/else to select the component to be handled can
        be avoided. If inner classes are used each component gets its own
        event handler and each event handler implicitly knows the
        component it is working for. e.g.

Button btn1 = new Button("Submit");
Btn.addActionListener(new ActionListener(){/br>


Public void actionPerformed(ActionEvent ae){ submitClicked(); }

} );
The advantage of using static nested class is that to instantiate
       a static nested class you need not create an instance of the
       enclosing class which reduces the number of objects the
       application creates at runtime.',1);
insert into Answers values(145,145,'Ans)
       1. Using inner class increases the total number of classes being
       used by the application. For all the classes created by JVM and
       loaded in the memory, jvm has to perform some tasks like creating
       the object of type class. Jvm may have to perform some routine
       tasks for these extra classes created which may result slower
       performance if the application is using more number of inner
       classes.
       2. Inner classes get limited support of ide/tools as compared to
       the top level classes, so working with the inner classes is
       sometimes annoying for the developer.',1);
insert into Answers values(146,146,'Ans 1)
Plain old anonymous class type one
-
e.g.
class superClass{
         void doSomething()
      {
                 
      System.out.println("Doing something in the Super
      class");
         }
 }

class hasAnonymous{
              
      superClass anon = new superClass(){
                 
           void doSomething() {
                 
                  
      System.out.println("Doing something in the Anonymous
      class");
                    
      }
           
      };
Here anon is the reference which is of type superClass which is the
      class extended by the anonymous class i.e. superclass of the
      anonymous class. The method doSomething() is the super class method
      overridden by the anonymous class.
2)
Plain old anonymous class type two
-

interface Eatable{
       public void prepareSweets();
 }
class serveMeal{
 Eatable food = new Eatable(){
              public void
      prepareSweets(){ //come implementation code goes here }
     };
}
 food is reference variable of type Eatable interface which
      refers to the anonymous class which is the implementer of the
      interface Eatable. The anonymous implementer class of the interface
      Eatable implements its method prepareSweets() inside it.
3)
Argument defined anonymous class
- e.g.

interface Vehicle {
   void getNoOfWheels();
 }
class Car {
       void getType(Vehical v) { }
}
class BeautifulCars {
        void
      getTheBeautifilCar() {
            
      Car c = new Car ();
            
      c.getType (new Vehicle () {
                 
              public void getNoOfWheels () {
                 
                    
      System.out.println("It has four wheels");
                 
              }
            
      });
        }
 }
 Anonymous class is defined as the argument of the method
      getTheBeautifilCar(), this anonymous class is the implementer of
      the interface Vehicle. The method of class Car getTheBeautifilCar()
      expects the argument as an object of type Vehicle. So first we
      create an object of Car referenced by the variable "c''.
      On this object of Car we call the method getTheBeautifilCar() and
      in the argument we create an anonymous class in place which is the
      implementer of interface Vehicle hence of type Vehicle.',1);
insert into Answers values(147,147,'Ans) If a inner class enclosed with an outer class is compiled
       then one .class file for each inner class an a .class file for the
       outer class is created. e.g.
class
EnclosingOuter
{
    class Inner{ }
 }
 If you compile the above code with command
% javac EnclosingOuter.java
Two files

EnclosingOuter.class
EnclosingOuter$Inner.class


will be created. Though a separate inner class file is generated,
       the inner class file is not accessible in the usual way like,
% java EnclosingOuter$Inner',1);
insert into Answers values(148,148,'Ans) The inner class is instantiated only through the outer class
      instance.
class EnclosingOuter {
private int noInnerClass = 1;
public void getNoOfInnerClasses(){
           Inner
      in = new Inner();
System.out.println("No Of Inner classes is : "+
in.getNoOfClassesFromOuter()
);
}
class Inner{

public int getNoOfClassesFromOuter(){ return noInnerClass; }

}
Here the method getNoOfInnerClasses() is called on the outer
      class''s instance through this outer class instance the inner
      class instance in is created.',1);
insert into Answers values(149,149,'Ans)
To create an instance of the inner class you must
       have the instance of its enclosing class
.
e.g. class EnclosingOuter {
class Inner{ }
}

 To create the instance of inner class from
       class other than the enclosing class.

1) class OtherThanOuter{
EnclosingOuter out = new EnclosingOuter();
EnclosingOuter.Inner in = out.new Inner();
}

2) class OtherThanOuter{
EnclosingOuter.Inner out = new EnclosingOuter.Inner (); }',1);
insert into Answers values(150,150,'Ans) The outer this reference i.e. the outer class'' current
      instance'' reference can be
refered using "OuterClassName.this''.
E.g
 class EnclosingOuter {
           class
      Inner{
         
      System.out.println("Inner class reference is " + this);
      // inner class instance


System.out.println("Outer class reference is " +
       EnclosingOuter.this); //outer class instance
 }
}

To refer the inner class reference from
        within the inner class use this.',1);
insert into Answers values(151,151,'Ans) Following are modifiers that can be applied to the inner:
     public
     private
     abstract
     final
     protected
     strictfp
     static - turns the inner class into
      static nested class.',1);
insert into Answers values(152,152,'Ans) No, a method local inner class object can not access the
      method local variable.

Reason
: The local variables are not guaranteed to
      live as long as the local inner class object. The method local
      variable live on stack and exist only till the method lives, their
      scope is limited only code inside the method they are declared in.
      But the local inner class object created within the method lives on
      heap and it may exist even after the method ends if in case the
      reference of this local inner class is passed into some other code
      and is stored in an instance variable. So we can not be sure that
      the local variables will live till the method local inner class
      object lives, therefore the method local inner class object can not
      access the method local variable. To access the method local
      variables, the variable has to be declared as final.',1);
insert into Answers values(153,153,'Ans) Yes. Because the final variables are stored on heap and
      they live as long as the method local inner class object may live.',1);
insert into Answers values(154,154,'Ans) Only abstract or final keyword isallowed.',1);
insert into Answers values(155,155,'Ans) No. There is no this reference available in the static method .The static method
      class can not have access to any members of the outer class other
      than static members.',1);
insert into Answers values(156,156,'Ans) No. Compilation will fail.As the reference variable type of
      the anonymous class will be of superclass which will not know of
      any method defined inside the anonymous class the compilation will
      fail.
e.g. class SuperClass{
            
      void doSomething() {
                      
      System.out.println("In the Super class");
            
      }
 }
class hasAnonymous{
SuperClass anon = new SuperClass(){
                void
      doSomething() {
                  
      System.out.println("In the Anonymous class");
                }
            
      void doStuff() {
                   
      System.out.println("An Anonymous class method not present in
      superClass");
           
      }
 };

public void doIt(){
      anon.doSomething(); // legal
      superClass has this method
      anon.doStuff(); // Not legal }
}
 The above code does not compile as the superClass does not
      know about the anonymous class method doStuff().',1);
insert into Answers values(157,157,'Ans) Yes. But there will be no way by which the methods defined in
      the anonymous class which are not present in its superclass be
      invoked. As only those methods which are defined in the suprclass
      which the anonymous class extends be invoked defining the methods
      in the anonymous class will be of no use.',1);
insert into Answers values(158,158,'Ans) No. An anonymous class can implement only one interface. If
      the anonymous class is extending a class then it becomes the
      implementer of all the interfaces implemented by its superclass
      automatically.',1);
insert into Answers values(159,159,'Ans)  Serializable is a marker interface. When an object has to be transferred over a network ( typically through rmi or EJB) or persist the state of an object to a file, the object Class needs to implement Serializable interface. Implementing this interface will allow the object converted into bytestream and transfer over a network.',1);
insert into Answers values(160,160,'Ans) During object serialization, the default Java serialization mechanism writes the
 metadata about the object, which includes the class name, field names and types,
 and superclass. This class definition is stored as a part of the serialized
 object. This stored metadata enables the deserialization process to reconstitute
 the objects and map the stream data into the class attributes with the
 appropriate type
Everytime an object is serialized the java serialization mechanism automatically computes a hash value. ObjectStreamClass''s
computeSerialVersionUID
() method passes the class name, sorted member names, modifiers, and interfaces to the secure hash algorithm (SHA), which returns a hash value.The serialVersionUID is also called
suid
.
So when the serilaize object is retrieved , the JVM first evaluates the
suid
of the serialized class and compares the
suid
value with the one of the object. If the suid values match then the object is said to be compatible with the class and hence it is de-serialized. If not
InvalidClassException
exception is thrown.
Changes to a serializable class can be compatible or incompatible. Following is the list of changes which are compatible:
Add fields
Change a field from static to non-static
Change a field from transient to non-transient
Add classes to the object tree
List of incompatible changes:
Delete fields
Change class hierarchy
Change non-static to static
Change non-transient to transient
Change type of a primitive field
So, if no suid is present , inspite of making compatible changes, jvm generates new
suid
thus resulting in an exception if prior release version object is used .
The only way to get rid of the exception is to recompile and deploy the application again.
If we explicitly metion the suid using the statement:
private final static long serialVersionUID = <integer value>

then if any of the metioned compatible changes are made the class need not to be recompiled. But for incompatible changes there is no other way than to compile again.',1);
insert into Answers values(161,161,'Ans) The serialization is used :-

To send  state of one or more object''s state over the network through a socket.

To save the state of an  object in a file.

An  object''s state needs to be manipulated as a stream of bytes.',1);
insert into Answers values(162,162,'Ans) Besides the Serializable interface, at least three alternate approaches can serialize Java objects:
1)For object serialization, instead of implementing the Serializable interface, a developer can implement the Externalizable interface, which extends Serializable. By implementing Externalizable, a developer is responsible for implementing the writeExternal() and readExternal() methods. As a result, a developer has sole control over reading and writing the serialized objects.
2)XML serialization is an often-used approach for data interchange. This approach lags runtime performance when compared with Java serialization, both in terms of the size of the object and the processing time. With a speedier XML parser, the performance gap with respect to the processing time narrows. Nonetheless, XML serialization provides a more malleable solution when faced with changes in the serializable object.
3)Finally, consider a "roll-your-own" serialization approach. You can write an object''s content directly via either the ObjectOutputStream or the DataOutputStream. While this approach is more involved in its initial implementation, it offers the greatest flexibility and extensibility. In addition, this approach provides a performance advantage over Java serialization.',1);
insert into Answers values(163,163,'Ans) No. Serializable is a Marker Interface. It does  not have any methods.',1);
insert into Answers values(164,164,'Ans) If the object to be serialized includes the  references to other objects whose class implements serializable then all those  object''s state also will be saved as the part of the serialized state of the  object in question. The whole object graph of the object to be serialized will  be saved during serialization automatically provided all the objects included  in the object''s graph are serializable.',1);
insert into Answers values(165,165,'Ans- If you try to serialize an object of a class  which implements serializable, but the object includes a reference to an  non-serializable class then a "NotSerializableException'' will be thrown at  runtime.

e.g.
public class NonSerial {
    //This is a non-serializable  class
}

public class MyClass implements Serializable{
    private static final long
serialVersionUID
= 1L;
    private NonSerial nonSerial;
    MyClass(NonSerial  nonSerial){
        this.nonSerial = nonSerial;
    }
    public static void main(String [] args)  {
        NonSerial nonSer = new NonSerial();
        MyClass c = new MyClass(nonSer);
        try {
        FileOutputStream fs = new FileOutputStream("test1.ser");
        ObjectOutputStream os = new ObjectOutputStream(fs);
        os.writeObject(c);
        os.close();
        } catch (Exception e) {  e.printStackTrace(); }
        try {
        FileInputStream fis = new FileInputStream("test1.ser");
        ObjectInputStream ois = new ObjectInputStream(fis);
        c = (MyClass)  ois.readObject();
        ois.close();
            } catch (Exception e) {
            e.printStackTrace();
          }
    }
}

On execution of above code following exception will be thrown  -

java.io.NotSerializableException
: NonSerial
            at java.io.ObjectOutputStream.writeObject0(
ObjectOutputStream.java
)',1);
insert into Answers values(166,166,'Ans) No. The static variables belong to the class  and not to an object they are not the part of the state of the object so they  are not saved as the part of serialized object.',1);
insert into Answers values(167,167,'Ans) These variables are not included in the  process of serialization and are not the part of the object''s serialized state.',1);
insert into Answers values(168,168,'Ans) It''s default value.
e.g. if the transient variable in question is an int, it''s value after  deserialization will be zero.


public class TestTransientVal implements Serializable{
   
    private static final long
serialVersionUID
=  -22L;
    private String name;
    transient private int age;
    TestTransientVal(int age, String  name) {
        this.age = age;
        this.name = name;
    }
    public static void main(String [] args)  {
        TestTransientVal c = new TestTransientVal(1,"ONE");
        System.
out
.println("Before  serialization: - " + c.name + " "+ c.age);
        try {
        FileOutputStream fs = new FileOutputStream("testTransients.ser");
        ObjectOutputStream os = new ObjectOutputStream(fs);
        os.writeObject(c);
        os.close();
        } catch (Exception e) {  e.printStackTrace(); }
        try {
        FileInputStream fis = new FileInputStream("testTransients.ser");
        ObjectInputStream ois = new ObjectInputStream(fis);
        c = (TestTransientVal)  ois.readObject();
        ois.close();
        } catch (Exception e) {  e.printStackTrace(); }
        System.
out
.println("After  de-serialization:- " + c.name + " "+ c.age);
        }

}



Result of executing above piece of code -
Before serialization: - Value of non-transient variable ONE Value of  transient variable 1
After de-serialization:- Value of non-transient  variable ONE Value of transient variable 0

Explanation -
The transient variable is not saved as the part of  the state of the serailized variable, it''s value after de-serialization is it''s  default value.',1);
insert into Answers values(169,169,'Ans) Yes.  As  while restoring the object''s state the transient variables and the serializable  variables that are stored must be restored in the same order in which they were  saved.',1);
insert into Answers values(170,170,'Ans) When you want to store the transient variables  state as a part of the serialized object at the time of serialization the class  must implement the following methods -

private void wrtiteObject(ObjectOutputStream outStream)
{
//code to save the transient variables state as a part of serialized  object
}
private void readObject(ObjectInputStream inStream)
{
//code to read the transient variables state and assign it to the  de-serialized object
}


e.g.

public class TestCustomizedSerialization implements Serializable{

    private static final long
serialVersionUID
=-22L;
    private String noOfSerVar;
    transient private int noOfTranVar;
    TestCustomizedSerialization(int noOfTranVar, String  noOfSerVar) {
        this.noOfTranVar = noOfTranVar;
        this.noOfSerVar = noOfSerVar;
    }
    private void writeObject(ObjectOutputStream os) {
     try {
     os.defaultWriteObject();
     os.writeInt(noOfTranVar);
     } catch (Exception e) {  e.printStackTrace(); }
     }
     private void readObject(ObjectInputStream is) {
     try {
     is.defaultReadObject();
     int noOfTransients =  (is.readInt());
     } catch (Exception e) {
         e.printStackTrace(); }
     }
     public int getNoOfTranVar() {
        return noOfTranVar;
    }
   
}

The value of transient variable "noOfTranVar'' is saved as part of the  serialized object manually by implementing writeObject() and restored by  implementing readObject().
The normal serializable variables are saved and restored by calling  defaultWriteObject() and defaultReadObject()respectively. These methods perform  the normal serialization and de-sirialization process for the object to be  saved or restored respectively.',1);
insert into Answers values(171,171,'Ans)  The values of the instance variables inherited  from superclass will be reset to the values they were given during the original  construction of the object as the non-serializable super-class constructor will  run.
E.g.

public class ParentNonSerializable {
    int noOfWheels;
   
    ParentNonSerializable(){
        this.noOfWheels = 4;
    }
   
}




public class ChildSerializable extends ParentNonSerializable implements Serializable {
   
    private static final long
serialVersionUID
= 1L;
    String color;

    ChildSerializable() {
        this.noOfWheels = 8;
        this.color = "blue";
    }
}




public class SubSerialSuperNotSerial {
    public static void main(String [] args)  {
        ChildSerializable c = new ChildSerializable();
        System.
out
.println("Before : -  " +  c.noOfWheels + " "+ c.color);
        try {
        FileOutputStream fs = new FileOutputStream("superNotSerail.ser");
        ObjectOutputStream os = new ObjectOutputStream(fs);
        os.writeObject(c);
        os.close();
        } catch (Exception e) {  e.printStackTrace(); }
        try {
        FileInputStream fis = new FileInputStream("superNotSerail.ser");
        ObjectInputStream ois = new ObjectInputStream(fis);
        c = (ChildSerializable) ois.readObject();
        ois.close();
        } catch (Exception e) {  e.printStackTrace(); }
        System.
out
.println("After :-  " +  c.noOfWheels + " "+ c.color);
        }

}

Result  on executing above code -
Before : - 8 blue
After :- 4 blue


The instance variable "noOfWheels'' is inherited from superclass which is  not serializable. Therefore while restoring it the non-serializable superclass  constructor runs and its value is set to 8 and is not same as the value saved  during serialization which is 4.',1);
insert into Answers values(172,172,'Ans)
Immutable class is a class which once created, it''s contents can  not be changed.
Immutable objects are the objects whose  state can not be changed once constructed.
e.g. String class',1);
insert into Answers values(173,173,'Ans)
To create an immutable class following steps should be followed:


Create a final class.

Set the values of properties  using constructor only.

Make the properties of the  class final and private

Do not provide any setters for  these properties.

If the instance fields include  references to mutable objects, don''t allow those objects to be changed:


Don''t provide methods that  modify the mutable objects.

Don''t share references to the  mutable objects. Never store references to external, mutable objects passed to  the constructor; if necessary, create copies, and store references to the  copies. Similarly, create copies of your internal mutable objects when  necessary to avoid returning the originals in your methods.



E.g.

public final class FinalPersonClass {
     
	private final String name;     
	private final int age;
          
	public FinalPersonClass(
		final String name,
		final int age) {
           super();
           this.name = name;           
			this.age = age;
        }
     
	public int getAge() {
           return age;
      }
     public String getName() {
           return name;
      }
}',1);
insert into Answers values(174,174,'Ans)
True. Since the state of the immutable objects can not be changed  once they are created they are automatically synchronized/thread-safe.',1);
insert into Answers values(175,175,'Ans)
All wrapper classes in java.lang are  immutable -
String, Integer, Boolean, Character, Byte, Short,  Long, Float, Double, BigDecimal, BigInteger',1);
insert into Answers values(176,176,'Ans) The advantages are: 
1) Immutable objects are automatically thread-safe, the overhead caused due to use of synchronisation is avoided.
2) Once created the state of the immutable object can not be changed so there is no possibility of them getting into an inconsistent state.
3) The references to the immutable objects can be easily shared or cached without having to copy or clone them as there state can not be changed ever after construction.
  4) The best use of the immutable objects is as the keys of a map.',1);
insert into Answers values(177,177,'Ans) Java supports two type of cloning: - Deep and shallow cloning. By  default shallow copy is used in Java. Object class has a method clone() which does  shallow cloning.',1);
insert into Answers values(178,178,'Ans) In
shallow copy
the object is copied without its contained objects.
Shallow clone only  copies the top level structure of the object not the lower levels.
It is an exact bit copy of all the attributes.      

The shallow copy is done for obj and new  object obj1 is created but contained objects of obj are not copied.

It can be seen that no new objects are  created for obj1 and it is referring to the same old contained objects. If  either of the containedObj contain any other object no new reference is  created',1);
insert into Answers values(179,179,'Ans) In deep copy the object is copied along with the objects it refers to. Deep  clone copies all the levels of the object from top to the bottom recursively.

When a deep copy of the object is done new  references are created.

One solution is to simply implement your own custom method (e.g., deepCopy()) that returns a deep copy of an instance of one of your classes. This may be the best solution if you need a complex mixture of deep and shallow copies for different fields, but has a few significant drawbacks:


You must be able to modify the class (i.e., have the source code) or implement a subclass. If you have a third-party class for which you do not have the source and which is marked final, you are out of luck.

You must be able to access all of the fields of the class’s superclasses. If significant parts of the object’s state are contained in private fields of a superclass, you will not be able to access them.

You must have a way to make copies of instances of all of the other kinds of objects that the object references. This is particularly problematic if the exact classes of referenced objects cannot be known until runtime.

Custom deep copy methods are tedious to implement, easy to get wrong, and difficult to maintain. The method must be revisited any time a change is made to the class or to any of its superclasses.


Other common solution to the deep copy problem is to use
Java Object Serialization
(JOS). The idea is simple: Write the object to an array using JOS’s
ObjectOutputStream
and then use
ObjectInputStream
to reconsistute a copy of the object. The result will be a completely distinct object, with completely distinct referenced objects. JOS takes care of all of the details: superclass fields, following object graphs, and handling repeated references to the same object within the graph.

It will only work when the object being copied, as well as all of the other objects references directly or indirectly by the object, are serializable. (In other words, they must implement java.io.Serializable.) Fortunately it is often sufficient to simply declare that a given class implements java.io.Serializable and let Java’s default serialization mechanisms do their thing. 
Java Object Serialization is slow, and using it to make a deep copy requires both serializing and deserializing.

There are ways to speed it up (e.g., by pre-computing serial version ids and defining custom readObject() and writeObject() methods), but this will usually be the primary bottleneck. 
The byte array stream implementations included in the java.io package are designed to be general enough to perform reasonable well for data of different sizes and to be safe to use in a multi-threaded environment. These characteristics, however, slow down ByteArrayOutputStream and (to a lesser extent) ByteArrayInputStream .',1);
insert into Answers values(180,180,'Ans) The differences are as follows:


Consider the class:



public class MyData{
String id;
Map myData;
}
The shallow copying of this object will have new id object and values as  "" but will point to the myData of the original object. So a change in myData  by either original or cloned object will be reflected in other also. But in  deep copying there will be new id object and also new myData object and independent  of original object but with same values.


Shallow copying is default cloning in Java which can be achieved       using clone() method of Object class. For deep copying some extra logic       need to be provided.',1);
insert into Answers values(181,181,'Ans) If we do a = clone(b)
1) Then b.equals(a)
2) No method of a can modify the value of b.',1);
insert into Answers values(182,182,'Ans) Disadvantages of using Serialization to achieve deep cloning –

Serialization is more expensive than using object.clone().
Not all objects are serializable.
Serialization is not simple to implement for deep cloned object..',1);
insert into Answers values(183,183,'Ans)
JSP (Java ServerPages)
is an extension of the Java Servlet technology. JSP is commonly used as the presentation layer for combining HTML and Java code. While Java Servlet technology is capable of generating HTML with out.println(“
…..
??) statements, where out is a PrintWriter. This process of embedding HTML code with escape characters is cumbersome and hard to maintain. The JSP technology solves this by providing a level of abstraction so that the developer can use custom tags and action elements, which can speed up Web development and are easier to maintain.
The JSPs have a translation or a compilation process where the JSP engine translates and compiles a JSP file into a JSP Servlet. The translated and compiled JSP Servlet moves to the execution phase (run time) where they can handle requests and send response.
Unless explicitly compiled ahead of time, JSP files are compiled the first time they are accessed. On large production sites, or in situations involving complicated JSP files, compilation may cause unacceptable delays to users first accessing the JSP page. The JSPs can be compiled ahead of time (ie precompiled) using application server tools/settings or by writing your own script.',1);
insert into Answers values(184,184,'Ans) Pre-translated: Before the JSP file has been translated and compiled into the Servlet.

Translated:
The JSP file has been translated and compiled as a Servlet.

Initialized:
Prior to handling the requests in the service method the container calls the jspInit() to initialize the
Servlet.
Called only once per Servlet instance.

Servicing:
Services the client requests. Container calls this method for each request.

Out of service:
The Servlet instance is out of service. The container calls the jspDestroy() method.',1);
insert into Answers values(185,185,'Ans)

Declaration Element
: is the embedded Java declaration statement, which gets inserted at the Servlet class level.

<%! Calendar c = Calendar.getInstance(); %>
Important: declaring variables via this element is not thread-safe, because this variable ends up in the generated Servlet as an instance variable, not within the body of the _jspservice() method. Ensure their access is either read-only or synchronized.

Expression Element:
is the embedded Java expression, which gets evaluated by the service method.

<%= new Date()>

Scriptlet Elements
: are the embedded Java statements, which get executed as part of the service method.
(Note: Not recommended to use Scriptlet elements because they don’t provide reusability and maintainability. Use custom tags (like JSTL, JSF tags, etc) or beans instead).

<%
//Java codes
String userName=null;
userName=request.getParameter("userName");
%>


Action Elements
: A JSP element that provides information for execution phase.

<jsp:useBean id="object_name" class="class_name"/>
<jsp:include page="scripts/login.jsp" />


Directive Elements
: A JSP element that provides global information for the translation phase.

<%@ page import=??java.util.Date?? %>
<%@ include file=??myJSP?? %>
<%@ taglib uri=??tagliburi?? prefix=??myTag??%>',1);
insert into Answers values(186,186,'Ans)

Scope:
Page
Object:
PageContext
Comment:
Available to the handling JSP page only.


Scope:
Request
Object:
Request
Comment:
Available to the handling JSP page or Servlet and forwarded JSP page or Servlet.


Scope:
Session
Object:
Session
Comment:
Available to any JSP Page or Servlet within the same session.


Scope:
Application
Object:
Application
Comment:
Available to all the JSP pages and Servlets within the same Web Application.',1);
insert into Answers values(187,187,'Ans)
1)
Static <%@include%>:
During the translation or compilation phase all the included JSP pages are compiled into a single Servlet.
Dynamic include <include....>:
The dynamically included JSP is compiled into a separate Servlet. It is a separate resource, which gets to process the request, and
the content generated by this resource is included in the JSP response.
2)
Static <%@include%>:
No run time performance overhead.
Dynamic include <include....>:
Has run time performance overhead.',1);
insert into Answers values(188,188,'Ans) No. The declaration of variables in JSP is not thread-safe, because the declared variables end up in the generated Servlet as an instance variable, not within the body of the _jspservice() method.
The following declaration is not thread safe: because these are declarations, and will only be evaluated once when the page is loaded 
<%! int a = 5 %>
The following declaration is thread safe: because the variables declared inside the scriplets have the local scope and not shared.
<% int a = 5 %>;',1);
insert into Answers values(189,189,'Ans) The JSP resources usually reside directly or under subdirectories (e.g. myPath) of the document root, which are directly accessible to the user through the URL. If you want to protect your Web resources then hiding the JSP files behind the WEB-INF directory can protect the JSP files, css (cascading style sheets) files, Java Script files, pdf files, image files, html files etc from direct access. The request should be made to a servlet who is responsible for authenticating and authorising the user before returning the protected JSP page or its resources.',1);
insert into Answers values(190,190,'Ans) Custom JSP tag is a tag you define. You define how a tag, its attributes and its body are interpreted, and then group your tags into collections called tag libraries that can be used in any number of JSP files. So basically it is a reusable and extensible JSP only solution. The pre-built tags also can speed up Web development.
Step 1
Create a Custom tag class using only doStartTag()

 package myTagPkg;
  public class MyTag extends TagSupport
   {
    int attr = null;
    public int setAttr(int a ttr){this.attr = a ttr}
    public int getAttr(){return attr;}
    public int doStartTag() throws JspException {
    .......
    return 0;
    }
    public void release(){.....}
   }

Step 2 The Tag library descriptor file (*.tld) maps the XML element names to the tag implementations. The code sample MyTagDesc.tld is shown below:

<taglib>
  <tag>
   <name>tag1</name>
   <tagclass>myTagPkg.MyTag</tagclass>
   <bodycontent>empty</bodycontent>
   <attribute>
    <name>attr</name>
    <required>false</required>
    <rtexprvalue>false</rtexprvalue>
   </attribute>
  </tag>
</taglib>

Step 3
The web.xml deployment descriptor maps the URI to the location of the *.tld (Tag Library Descriptor) file. The code sample web.xml file is shown below:

 <web-app>
  <taglib>
   <taglib-uri>/WEB-INF/MyTagURI</taglib-uri>
   <taglib-location>/WEB-INF/tags/MyTagDesc.tld</taglib-location>
  </taglib>
 </web-app>

STEP: 4
The JSP file declares and then uses the tag library as shown below:

<%@ taglib uri="/WEB-INF/ MyTagURI" prefix="myTag" %>
< myTag:tag1 attr=â€?abcâ€? />
<taglib>
  <tag>
   <name>tag1</name>
   <tagclass>myTagPkg.MyTag</tagclass>
   <bodycontent>empty</bodycontent>
   <attribute>
    <name>attr</name>
    <required>false</required>
    <rtexprvalue>false</rtexprvalue>
   </attribute>
  </tag>
</taglib>',1);
insert into Answers values(191,191,'Ans)
 In the context of a JSP page, both accomplish similar goals but the differences are:

1)
Custom Tags
Can manipulate JSP content.
JavaBeans
Can''t manipulate JSP content.

2)
Custom Tags
Custom tags can simplify the complex operations much
better than the bean can. But require a bit more work to
set up.
JavaBeans
Easier to set up.

3)
Custom Tags
Used only in JSPs in a relatively self-contained manner.
JavaBeans
Can be used in both Servlets and JSPs. You can define a bean in
one Servlet and use them in another Servlet or a JSP page.

4)
Custom Tags
JavaBeans declaration and usage example:
JavaBeans
<jsp:useBean id="identifier" class="packageName.className"/>
<jsp:setProperty name="identifier" property="classField" value="someValue" />
<jsp:getProperty name="identifier" property="classField" />
<%=identifier.getclassField() %>',1);
insert into Answers values(192,192,'A: An expression tag contains a scripting language expression that is evaluated, converted to a String, and inserted where the expression appears in the JSP file. Because the value of an expression is converted to a String, you can use an expression within text in a JSP file. Like
<%= someexpression %>
<%= (new java.util.Date()).toLocaleString() %>
You cannot use a semicolon to end an expression.',1);
insert into Answers values(193,193,'Ans) When you invoke a forward request, the request is sent to another resource on the server, without the client being informed that a different resource is going to process the request. This process occurs completly with in the web container. When a sendRedirtect method is invoked, it causes the web container to return to the browser indicating that a new URL should be requested. Because the browser issues a completly new request any object that are stored as request attributes before the redirect occurs will be lost. This extra round trip a redirect is slower than forward.',1);
insert into Answers values(194,194,'Ans) Certain objects that are available for the use in JSP documents without being declared first. These objects are parsed by the JSP engine and inserted into the generated servlet. The implicit objects are listed below:

request
response
pageContext
session
application
out
config
page
exception',1);
insert into Answers values(195,195,'Ans)  You will need to set the appropriate HTTP header attributes to prevent the dynamic content output by the JSP page from being cached by the browser. Just execute the following scriptlet at the beginning of your JSP pages to prevent them from being cached at the browser. You need both the statements to take care of some of the older browser versions.
<%
response.setHeader("Cache-Control","no-store"); //HTTP 1.1
response.setHeader("Pragma\","no-cache"); //HTTP 1.0
response.setDateHeader ("Expires", 0); //prevents caching at the proxy server
%>',1);
insert into Answers values(196,196,'Ans)  JSPs can be thread-safe by having them implement the SingleThreadModel interface. This is done by adding the directive

<%@ page isThreadSafe="false" %>
within your JSP page. With this, instead of a single instance of the servlet generated for your JSP page loaded in memory, you will have N instances of the servlet loaded and initialized, with the service method of each instance effectively synchronized. You can typically control the number of instances (N) that are instantiated for all servlets implementing SingleThreadModel through the admin screen for your JSP engine. More importantly, avoid using the tag for variables. If you do use this tag, then you should set isThreadSafe to true, as mentioned above. Otherwise, all requests to that page will access those variables, causing a nasty race condition. SingleThreadModel is not recommended for normal use. There are many pitfalls, including the example above of not being able to use <%! %>. You should try really hard to make them thread-safe the old fashioned way: by making them thread-safe .',1);
insert into Answers values(197,197,'Ans) Because the servlet init() method is invoked when servlet instance is loaded, it is the
perfect location to carry out expensive operations that need only be performed during
initialization. By definition, the init() method is thread-safe. The results of operations in
the HttpServlet.init() method can be cached safely in servlet instance variables, which
become read-only in the servlet service method.',1);
insert into Answers values(198,198,'Ans) By default, JSP files create HttpSessions. This is in compliance with J2EETM to facilitate
the use of JSP implicit objects, which can be referenced in JSP source and tags without
explicit declaration. HttpSession is one of those objects. If you do not use HttpSession
in your JSP files then you can save some performance overhead with the following JSP
page directive:
<%@ page session="false"%>',1);
insert into Answers values(199,199,'Ans) Java doesnt support multiple inheritance but it provide a way through which it can enact it. 
Consider the scenario is C++
Class A{

public void add(){
// some text
}
}

Class B{

public void add(){
// some text
}
}

Class C extends A,B{

public static void main(String arg[]){

C objC = new C();
objC.add(); // problem, compiler gets confused and cant
decide to call Class A or B method.
}

This problem is called Diamond problem.

This problem in java is taken care with the use of interfaces
In Java similar problem would look like:
interface A{
add();
}

interface B{
add();
}

class C implements A,B{

add(){
// doesnt matter which interface it belong to
}
}',1);
insert into Answers values(200,200,'NO',1);
insert into Answers values(201,201,'Ans) Java has a more expressive system of reference than most other garbage-collected programming languages, which allows for special behavior for garbage collection. A normal reference in Java is known as a strong reference. The java.lang.ref package defines three other types of references—soft, weak, and phantom references. Each type of reference is designed for a specific use.

A SoftReference can be used to implement a cache. An object that is not reachable by a strong reference (that is, not strongly reachable), but is referenced by a soft reference is called softly reachable. A softly reachable object may be garbage collected at the discretion of the garbage collector. This generally means that softly reachable objects will only be garbage collected when free memory is low, but again, it is at the discretion of the garbage collector. Semantically, a soft reference means "keep this object unless the memory is needed."

A WeakReference is used to implement weak maps. An object that is not strongly or softly reachable, but is referenced by a weak reference is called weakly reachable. A weakly reachable object will be garbage collected during the next collection cycle. This behavior is used in the class java.util.WeakHashMap. A weak map allows the programmer to put key/value pairs in the map and not worry about the objects taking up memory when the key is no longer reachable anywhere else. Another possible application of weak references is the string intern pool. Semantically, a weak reference means "get rid of this object when nothing else references it."


A PhantomReference is used to reference objects that have been marked for garbage collection and have been finalized, but have not yet been reclaimed. An object that is not strongly, softly or weakly reachable, but is referenced by a phantom reference is called phantom reachable. This allows for more flexible cleanup than is possible with the finalization mechanism alone. Semantically, a phantom reference means "this object is no longer needed and has been finalized in preparation for being collected."',1);
insert into Answers values(202,202,'Ans) The old generation''s default heap size can be overridden by using the -Xms and -Xmx switches to specify the initial and maximum sizes respectively: 
java -Xms <initial size> -Xmx <maximum size> program
For example: 
java -Xms64m -Xmx128m program',1);
insert into Answers values(203,203,'Ans) Differences are as follows:

1) instanceof is a reserved word of Java, but isInstance(Object obj) is a method of java.lang.Class.

if (obj instanceof MyType) {
...
}else if (MyType.class.isInstance(obj)) {
...
}

2) instanceof is used of identify whether the object is type of a particular class or its subclass but isInstance(obj) is used to identify object of a particular class.',1);
insert into Answers values(204,204,'Ans) Java supports only pass by value. The arguments passed as a parameter to a method is mainly primitive data types or objects. For the data type the actual value is passed.
Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references.Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects.Consider the example:
 public void tricky(Point arg1, Point arg2)
 {
   arg1.x = 100;
   arg1.y = 100;
   Point temp = arg1;
   arg1 = arg2;
   arg2 = temp;
 }
 public static void main(String [] args)
 {
   Point pnt1 = new Point(0,0);
   Point pnt2 = new Point(0,0);
   System.out.println("X: " + pnt1.x + " Y: " +pnt1.y); 
   System.out.println("X: " + pnt2.x + " Y: " +pnt2.y);
   System.out.println(" ");
   tricky(pnt1,pnt2);
   System.out.println("X: " + pnt1.x + " Y:" + pnt1.y); 
   System.out.println("X: " + pnt2.x + " Y: " +pnt2.y); 
 }

OutPut:
X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references.',1);
insert into Answers values(205,205,'Ans) A memory leak is where an unreferenced object that will never be used again still hangs around in memory and doesnt get garbage collected.',1);
insert into Answers values(206,206,'Ans) == operator is used to compare the references of the objects. 
public bollean equals(Object o) is the method provided by the Object class. The default implementation uses == operator to compare two objects.
But since the method can be overriden like for String class. equals() method can be used to compare the values of two objects.
 String str1 = "MyName"; 
 String str2 = "MyName";
 String str3 = str2;

 if(str1 == str2){
 System.out.println("Objects are equal")
 }else{
 System.out.println("Objects are not equal")
 }

 if(str1.equals(str2)){
 System.out.println("Objects are equal")
 }else{
 System.out.println("Objects are not equal")
 }

 Output:

 Objects are not equal
 Objects are equal



 String str2 = "MyName";
 String str3 = str2;

 if(str2 == str3){
 System.out.println("Objects are equal")
 }else{
 System.out.println("Objects are not equal")
 }

 if(str3.equals(str2)){
 System.out.println("Objects are equal")
 }else{
 System.out.println("Objects are not equal")
 }

 OutPut:
 Objects are equal
 Objects are equal',1);
insert into Answers values(207,207,'Ans) The @Override annotation can be added to the javadoc for the new method. If you accidently miss an argument or capitalize the method name wrong, the compiler will generate a compile-time error.',1);
insert into Answers values(208,208,'Ans)The heap size of an object can be found using -

         Runtime.totalMemory()-Runtime.freeMemory() .',1);
insert into Answers values(209,209,'Ans)
Spring is an open source development framework for enterprise Java. The core features of the Spring Framework can be used in developing any Java application, but there are extensions for building web applications on top of the Java EE platform. Spring framework targets to make J2EE development easier to use and promote good programming practice by enabling a POJO-based programming model.',1);
insert into Answers values(210,210,'Ans)
Following is the list of few of the great benefits of using Spring Framework:


Lightweight:
Spring is lightweight when it comes to size and transparency. The basic version of spring framework is around 2MB.

Inversion of control (IOC):
Loose coupling is achieved in spring using the technique Inversion of Control. The objects give their dependencies instead of creating or looking for dependent objects.

Aspect oriented (AOP):
Spring supports Aspect oriented programming and enables cohesive development by separating application business logic from system services.

Container:
Spring contains and manages the life cycle and configuration of application objects.

MVC Framework:
Spring''s web framework is a well-designed web MVC framework, which provides a great alternative to web frameworks such as Struts or other over engineered or less popular web frameworks.

Transaction Management:
Spring provides a consistent transaction management interface that can scale down to a local transaction (using a single database, for example) and scale up to global transactions (using JTA, for example).

Exception Handling:
Spring provides a convenient API to translate technology-specific exceptions (thrown by JDBC, Hibernate, or JDO, for example) into consistent, unchecked exceptions.',1);
insert into Answers values(211,211,'Ans)
Following are the modules of the Spring framework:


Core module

Bean module

Context module

Expression Language module

JDBC module

ORM module

OXM module

Java Messaging Service(JMS) module

Transaction module

Web module

Web-Servlet module

Web-Struts module

Web-Portlet module',1);
insert into Answers values(212,212,'Ans)
Spring configuration file is an XML file. This file contains the classes information and describes how these classes are configured and introduced to each other.',1);
insert into Answers values(213,213,'Ans)
Inversion of Control (IoC) is a general concept, and it can be expressed in many different ways and Dependency Injection is merely one concrete example of Inversion of Control.

This concept says that you do not create your objects but describe how they should be created. You don''t directly connect your components and services together in code but describe which services are needed by which components in a configuration file. A container (the IOC container) is then responsible for hooking it all up.',1);
insert into Answers values(214,214,'Ans)
Types of IoC are:


Constructor-based dependency injection:
Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on other class.

Setter-based dependency injection:
Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.',1);
insert into Answers values(215,215,'Ans)
Since you can mix both, Constructor- and Setter-based DI, it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the use of a
@Required
annotation on a setter can be used to make setters required dependencies.',1);
insert into Answers values(216,216,'Ans)
The main benefits of IOC or dependency injection are:


It minimizes the amount of code in your application.

It makes your application easy to test as it doesn''t require any singletons or JNDI lookup mechanisms in your unit test cases.

Loose coupling is promoted with minimal effort and least intrusive mechanism.

IOC containers support eager instantiation and lazy loading of services.',1);
insert into Answers values(217,217,'Ans)
Aspect-oriented programming, or AOP, is a programming technique that allows programmers to modularize crosscutting concerns, or behavior that cuts across the typical divisions of responsibility, such as logging and transaction management. The core construct of AOP is the aspect, which encapsulates behaviors affecting multiple classes into reusable modules.',1);
insert into Answers values(218,218,'Ans)
The Spring IoC creates the objects, wire them together, configure them, and manage their complete lifecycle from creation till destruction. The Spring container uses dependency injection (DI) to manage the components that make up an application.',1);
insert into Answers values(219,219,'Ans)
There are two types of IoC containers:


Bean Factory container:
This is the simplest container providing basic support for DI .The BeanFactory is usually preferred where the resources are limited like mobile devices or applet based applications

Spring ApplicationContext Container:
This container adds more enterprise-specific functionality such as the ability to resolve textual messages from a properties file and the ability to publish application events to interested event listeners.',1);
insert into Answers values(220,220,'Ans)
The most commonly used BeanFactory implementation is the
XmlBeanFactory
class. This container reads the configuration metadata from an XML file and uses it to create a fully configured system or application.',1);
insert into Answers values(221,221,'Ans)
The three commonly used implementation of ''Application Context'' are:


FileSystemXmlApplicationContext:
This container loads the definitions of the beans from an XML file. Here you need to provide the full path of the XML bean configuration file to the constructor.

ClassPathXmlApplicationContext:
This container loads the definitions of the beans from an XML file. Here you do not need to provide the full path of the XML file but you need to set CLASSPATH properly because this container will look bean configuration XML file in CLASSPATH.

WebXmlApplicationContext:
This container loads the XML file with definitions of all beans from within a web application.',1);
insert into Answers values(222,222,'Ans)
Following are some of the differences:


Application contexts provide a means for resolving text messages, including support for i18n of those messages.

Application contexts provide a generic way to load file resources, such as images.

Application contexts can publish events to beans that are registered as listeners.

Certain operations on the container or beans in the container, which have to be handled in a programmatic fashion with a bean factory, can be handled declaratively in an application context.

The application context implements MessageSource, an interface used to obtain localized messages, with the actual implementation being pluggable.',1);
insert into Answers values(223,223,'Ans)
The objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. These beans are created with the configuration metadata that you supply to the container, for example, in the form of XML <bean/> definitions.',1);
insert into Answers values(224,224,'Ans)
The bean definition contains the information called configuration metadata which is needed for the container to know the followings:


How to create a bean

Bean''s lifecycle details

Bean''s dependencies',1);
insert into Answers values(225,225,'Ans)
There are following three important methods to provide configuration metadata to the Spring Container:


XML based configuration file.

Annotation-based configuration

Java-based configuration',1);
insert into Answers values(226,226,'Ans)
Check the following example:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
       <property name="message" value="Hello World!"/>
   </bean>

</beans>',1);
insert into Answers values(227,227,'Ans)
When defining a <bean> in Spring, you have the option of declaring a scope for that bean. For example, to force Spring to produce a new bean instance each time one is needed, you should declare the bean''s scope attribute to be
prototype
.  Similar way if you want Spring to return the same bean instance each time one is needed, you should declare the bean''s scope attribute to be
singleton.',1);
insert into Answers values(228,228,'Ans)
The Spring Framework supports following five scopes, three of which are available only if you use a web-aware ApplicationContext.


singleton:
This scopes the bean definition to a single instance per Spring IoC container.

prototype:
This scopes a single bean definition to have any number of object instances.

request:
This scopes a bean definition to an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.

session:
This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.

global-session:
This scopes a bean definition to a global HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.',1);
insert into Answers values(229,229,'Ans)
The default scope of bean is Singleton for Spring framework.',1);
insert into Answers values(230,230,'Ans)
No, singleton beans are not thread-safe in Spring framework.',1);
insert into Answers values(231,231,'Ans)
Following is sequence of a bean lifecycle in Spring:


Instantiate
- First the spring container finds the bean''s definition from the XML file and instantiates the bean..

Populate properties
- Using the dependency injection, spring populates all of the properties as specified in the bean definition..

Set Bean Name
- If the bean implements BeanNameAware interface, spring passes the  bean''s id to setBeanName() method.

Set Bean factory
- If Bean implements BeanFactoryAware interface, spring passes the beanfactory to setBeanFactory() method.

Pre Initialization
-  Also called postprocess of bean. If there are any bean BeanPostProcessors associated with the bean,  Spring calls postProcesserBeforeInitialization() method.

Initialize beans
- If the bean implements IntializingBean,its afterPropertySet() method is called. If the bean has init method declaration, the specified initialization method is called.

Post Initialization
-  If there are any BeanPostProcessors associated with the bean, their postProcessAfterInitialization() methods will be called.

Ready to use
- Now the bean is ready to use by the application.

Destroy
- If the bean implements DisposableBean , it will call the destroy() method .',1);
insert into Answers values(232,232,'Ans)
A <bean/> element inside the <property/> or <constructor-arg/> elements defines a so-called inner bean. An inner bean definition does not require a defined id or name; the container ignores these values. It also ignores the scope flag.  Inner beans are always anonymous and they are always scoped as prototypes.',1);
insert into Answers values(233,233,'Ans)
Spring offers four types of collection configuration elements which are as follows:


<list>
: This helps in wiring i.e. injecting a list of values, allowing duplicates.

<set>
: This helps in wiring a set of values but without any duplicates.

<map>
: This can be used to inject a collection of name-value pairs where name and value can be of any type.

<props>
: This can be used to inject a collection of name-value pairs where the name and value are both Strings.',1);
insert into Answers values(234,234,'Ans)
The Spring container is able to autowire relationships between collaborating beans. This means that it is possible to automatically let Spring resolve collaborators (other beans) for your bean by inspecting the contents of the BeanFactory without using <constructor-arg> and <property> elements.',1);
insert into Answers values(235,235,'Ans)
The autowiring functionality has five modes which can be used to instruct Spring container to use autowiring for dependency injection:


no
: This is default setting which means no autowiring and you should use explicit bean reference for wiring. You have nothing to do special for this wiring. This is what you already have seen in Dependency Injection chapter.

byName
: Autowiring by property name. Spring container looks at the properties of the beans on which autowire attribute is set to byName in the XML configuration file. It then tries to match and wire its properties with the beans defined by the same names in the configuration file.

byType
: Autowiring by property datatype. Spring container looks at the properties of the beans on which autowire attribute is set to byType in the XML configuration file. It then tries to match and wire a property if its type matches with exactly one of the beans name in configuration file. If more than one such beans exist, a fatal exception is thrown.

constructor
: Similar to byType, but type applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.

autodetect
: Spring first tries to wire using autowire by constructor, if it does not work, Spring tries to autowire by byType.',1);
insert into Answers values(236,236,'Ans)
Limitations of autowiring are:


Overriding possibility
: You can still specify dependencies using <constructor-arg> and <property> settings which will always override autowiring.

Primitive data types
: You cannot autowire so-called simple properties such as primitives, Strings, and Classes.

Confusing nature
: Autowiring is less exact than explicit wiring, so if possible prefer using explicit wiring.',1);
insert into Answers values(237,237,'Ans)
Yes.',1);
insert into Answers values(238,238,'Ans)
An alternative to XML setups is provided by annotation-based configuration which relies on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration.',1);
insert into Answers values(239,239,'Ans)
Annotation wiring is not turned on in the Spring container by default. So, before we can use annotation-based wiring, we will need to enable it in our Spring configuration file by configuring <context:annotation-config/>.',1);
insert into Answers values(240,240,'Ans)
This annotation simply indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws BeanInitializationException if the affected bean property has not been populated.',1);
insert into Answers values(241,241,'Ans)
This annotation provides more fine-grained control over where and how autowiring should be accomplished. The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.',1);
insert into Answers values(242,242,'Ans)
There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property, in such case you can use @Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be wired.',1);
insert into Answers values(243,243,'Ans)
Spring has JSR-250 based annotations which include @PostConstruct, @PreDestroy and @Resource annotations.


@PostConstruct
: This annotation can be used as an alternate of initialization callback.

@PreDestroy
: This annotation can be used as an alternate of destruction callback.

@Resource
: This annotation can be used on fields or setter methods. The @Resource annotation takes a ''name'' attribute which will be interpreted as the bean name to be injected. You can say, it follows by-name autowiring semantics.',1);
insert into Answers values(244,244,'Ans)
Java based configuration option enables you to write most of your Spring configuration without XML but with the help of few Java-based annotations.

For example: Annotation
@Configuration
indicates that the class can be used by the Spring IoC container as a source of bean definitions. The
@Bean
annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context.',1);
insert into Answers values(245,245,'Ans)
Event handling in the
ApplicationContext
is provided through the
ApplicationEvent
class and
ApplicationListener
interface. So if a bean implements the
ApplicationListener
, then every time an
ApplicationEvent
gets published to the ApplicationContext, that bean is notified.',1);
insert into Answers values(246,246,'Ans)
Spring provides the following standard events:


ContextRefreshedEvent
: This event is published when the ApplicationContext is either initialized or refreshed. This can also be raised using the refresh() method on the ConfigurableApplicationContext interface.

ContextStartedEvent
: This event is published when the ApplicationContext is started using the start() method on the ConfigurableApplicationContext interface. You can poll your database or you can re/start any stopped application after receiving this event.

ContextStoppedEvent
: This event is published when the ApplicationContext is stopped using the stop() method on the ConfigurableApplicationContext interface. You can do required housekeep work after receiving this event.

ContextClosedEvent
: This event is published when the ApplicationContext is closed using the close() method on the ConfigurableApplicationContext interface. A closed context reaches its end of life; it cannot be refreshed or restarted.

RequestHandledEvent
: This is a web-specific event telling all beans that an HTTP request has been serviced.',1);
insert into Answers values(247,247,'Ans)
A module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement. In Spring AOP, aspects are implemented using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (@AspectJ style).',1);
insert into Answers values(248,248,'Ans)

Concern
: Concern is behavior which we want to have in a module of an application. Concern may be defined as a functionality we want to implement. Issues in which we are interested define our concerns.

Cross-cutting concern
: It''s a concern which is applicable throughout the application and it affects the entire application. e.g. logging , security and data transfer are the concerns which are needed in almost every module of an application, hence are cross-cutting concerns.',1);
insert into Answers values(249,249,'Ans)
This represents a point in your application where you can plug-in AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.',1);
insert into Answers values(250,250,'Ans)
This is the actual action to be taken either before or after the method execution. This is actual piece of code that is invoked during program execution by Spring AOP framework.',1);
insert into Answers values(251,251,'Ans)
This is a set of one or more joinpoints where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.',1);
insert into Answers values(252,252,'Ans)
An introduction allows you to add new methods or attributes to existing classes.',1);
insert into Answers values(253,253,'Ans)
The object being advised by one or more aspects, this object will always be a proxy object. Also referred to as the advised object.',1);
insert into Answers values(254,254,'Ans)
Weaving is the process of linking aspects with other application types or objects to create an advised object.',1);
insert into Answers values(255,255,'Ans)
Weaving can be done at compile time, load time, or at runtime.',1);
insert into Answers values(256,256,'Ans)
Spring aspects can work with five kinds of advice mentioned below:


before
: Run advice before the a method execution.

after
: Run advice after the a method execution regardless of its outcome.

after-returning
: Run advice after the a method execution only if method completes successfully.

after-throwing
: Run advice after the a method execution only if method exits by throwing an exception.

around
: Run advice before and after the advised method is invoked.',1);
insert into Answers values(257,257,'Ans)
Aspects are implemented using regular classes along with XML based configuration.',1);
insert into Answers values(258,258,'Ans)
@AspectJ refers to a style of declaring aspects as regular Java classes annotated with Java 5 annotations.',1);
insert into Answers values(259,259,'Ans)
JDBC can be used more efficiently with the help of a template class provided by spring framework called as JdbcTemplate.',1);
insert into Answers values(260,260,'Ans)
With use of Spring JDBC framework the burden of resource management and error handling is reduced a lot. So it leaves developers to write the statements and queries to get the data to and from the database. JdbcTemplate provides many convenience methods for doing things such as converting database data into primitives or objects, executing prepared and callable statements, and providing custom database error handling.',1);
insert into Answers values(261,261,'Ans)
Spring supports two types of transaction management:


Programmatic transaction management:
This means that you have managed the transaction with the help of programming. That gives you extreme flexibility, but it is difficult to maintain.

Declarative transaction management:
This means you separate transaction management from the business code. You only use annotations or XML based configuration to manage the transactions.',1);
insert into Answers values(262,262,'Ans)
Declarative transaction management is preferable over programmatic transaction management though it is less flexible than programmatic transaction management, which allows you to control transactions through your code.',1);
insert into Answers values(263,263,'Ans)
The Spring web MVC framework provides model-view-controller architecture and ready components that can be used to develop flexible and loosely coupled web applications. The MVC pattern results in separating the different aspects of the application (input logic, business logic, and UI logic), while providing a loose coupling between these elements.',1);
insert into Answers values(264,264,'Ans)
The Spring Web MVC framework is designed around a DispatcherServlet that handles all the HTTP requests and responses.',1);
insert into Answers values(265,265,'Ans)
The
WebApplicationContext
is an extension of the plain
ApplicationContext
that has some extra features necessary for web applications. It differs from a normal
ApplicationContext
in that it is capable of resolving themes, and that it knows which servlet it is associated with.',1);
insert into Answers values(266,266,'Ans)
Following are some of the advantages of Spring MVC over Struts MVC:


Spring''s MVC is very versatile and flexible based on interfaces but Struts forces Actions and Form object into concrete inheritance.

Spring provides both interceptors and controllers, thus helps to factor out common behavior to the handling of many requests.

Spring can be configured with different view technologies like Freemarker, JSP, Tiles, Velocity, XLST etc. and also you can create your own custom view mechanism by implementing Spring View interface.

In Spring MVC Controllers can be configured using DI (IOC) that makes its testing and integration easy.

Web tier of Spring MVC is easy to test than Struts web tier, because of the avoidance of forced concrete inheritance and explicit dependence of controllers on the dispatcher servlet.

Struts force your Controllers to extend a Struts class but Spring doesn''t, there are many convenience Controller implementations that you can choose to extend.

In Struts, Actions are coupled to the view by defining ActionForwards within a ActionMapping or globally. SpringMVC has HandlerMapping interface to support this functionality.

With Struts, validation is usually performed (implemented) in the validate method of an ActionForm. In SpringMVC, validators are business objects that are NOT dependent on the Servlet API which makes these validators to be reused in your business logic before persisting a domain object to a database.',1);
insert into Answers values(267,267,'Ans)
Controllers provide access to the application behavior that you typically define through a service interface. Controllers interpret user input and transform it into a model that is represented to the user by the view. Spring implements a controller in a very abstract way, which enables you to create a wide variety of controllers.',1);
insert into Answers values(268,268,'Ans)
The
@Controller
annotation indicates that a particular class serves the role of a controller. Spring does not require you to extend any controller base class or reference the Servlet API.',1);
insert into Answers values(269,269,'Ans)

@RequestMapping
annotation is used to map a URL to either an entire class or a particular handler method.',1);
insert into Answers values(270,270,'Ans)
There are two ways to access hibernate using spring:


Inversion of Control with a Hibernate Template and Callback.

Extending HibernateDAOSupport and Applying an AOP Interceptor node.',1);
insert into Answers values(271,271,'Ans) Spring supports the following ORM''s :

Hibernate

iBatis

JPA (Java Persistence API)

TopLink

JDO (Java Data Objects)

OJB',1);
insert into Answers values(272,272,'Ans)
A servlet is a Java programming language class that is used to extend the capabilities of servers that host applications accessed by means of a request- response programming model. Before the servlet, CGI scripting language was used as server side programming language.',1);
insert into Answers values(273,273,'Ans)
Uses of servlet includes:


Processing and storing data submitted by an HTML form.

Providing dynamic content.

A Servlet can handle multiple request concurrently and be used to develop high performance system

Managing state information on top of the stateless HTTP.',1);
insert into Answers values(274,274,'Ans)
Life cycle of Servlet:


Servlet class loading

Servlet instantiation

Initialization (call the init method)

Request handling (call the service method)

Removal from service (call the destroy method)',1);
insert into Answers values(275,275,'Ans)
Even though there is an init method in a servlet which gets called to initialize it, a constructor is still required to instantiate the servlet. Even though you as the developer would never need to explicitly call the servlet''s constructor, it is still being used by the container.',1);
insert into Answers values(276,276,'Ans)
The servlet is loaded by:


First request is made.

Server starts up (auto-load).

There is only a single instance which answers all requests concurrently. This saves memory and allows a Servlet to easily manage persistent data.

Administrator manually loads.',1);
insert into Answers values(277,277,'Ans)
Servlet gets unloaded when:


Server shuts down.

Administrator manually unloads.',1);
insert into Answers values(278,278,'Ans)
The central abstraction in the Servlet API is the Servlet interface. All servlets implement this interface, either directly or more commonly by extending a class that implements it.',1);
insert into Answers values(279,279,'Ans)
GenericServlet is an abstract class that implements the Servlet interface and the ServletConfig interface. In addition to the methods declared in these two interfaces, this class also provides simple versions of the lifecycle methods init () and destroy (), and implements the log method declared in the ServletContext interface.',1);
insert into Answers values(280,280,'Ans)
The difference is:


The GenericServlet is an abstract class that is extended by HttpServlet to provide HTTP protocol-specific methods. But HttpServlet extends the GenericServlet base class and provides a framework for handling the HTTP protocol.

The GenericServlet does not include protocol-specific methods for handling request parameters, cookies, sessions and setting response headers. The HttpServlet subclass passes generic service method requests to the relevant doGet () or doPost () method.

GenericServlet is not specific to any protocol. HttpServlet only supports HTTP and HTTPS protocol.',1);
insert into Answers values(281,281,'Ans)
The HttpServlet class is declared abstract because the default implementations of the main service methods do nothing and must be overridden. This is a convenience implementation of the Servlet interface, which means that developers do not need to implement all service methods.
If your servlet is required to handle doGet () requests for example, there is no need to write a doPost () method too.',1);
insert into Answers values(282,282,'Ans)
Yes',1);
insert into Answers values(283,283,'Ans)
It extends the GenericServlet base class and provides a framework for handling the HTTP protocol. So, HttpServlet only supports HTTP and HTTPS protocol.',1);
insert into Answers values(284,284,'Ans)
The difference is:


In doGet() the parameters are appended to the URL and sent along with header information. In doPost (),send the information through a socket back to the webserver and it won''t show up in the URL bar.

The amount of information you can send back using a GET is restricted as URLs can only be 1024 characters. You can send much more information to the server by using post and it''s not restricted to textual data either. It is possible to send files and even binary data such as serialized Java objects!

DoGet() is a request for information.It does not change anything on the server. (doGet () should be idempotent). doPost () provides information (such as placing an order for merchandise) that the server is expected to remember.',1);
insert into Answers values(285,285,'Ans)
Always prefer to use GET (As because GET is faster than POST), except mentioned in the following reason:


If data is sensitive.

Data is greater than 1024 characters.

If your application don''t need bookmarks.',1);
insert into Answers values(286,286,'Ans)
The easy way is, just support POST, then have your doGet method call your doPost method.',1);
insert into Answers values(287,287,'Ans)
We never override the service method, since the HTTP Servlets have already taken care of it. The default service function invokes the doXXX() method corresponding to the method of the HTTP request. For example, if the HTTP request method is GET, doGet () method is called by default.
A servlet should override the doXXX() method for the HTTP methods that servlet supports. Because HTTP service method checks the request method and calls the appropriate handler method, it is not necessary to override the service method itself. Only override the appropriate doXXX() method.',1);
insert into Answers values(288,288,'Ans)
A servlet context object contains the information about the Web application of which the servlet is a part. It also provides access to the resources common to all the servlets in the application. Each Web application in a container has a single servlet context associated with it.',1);
insert into Answers values(289,289,'Ans)
The ServletConfig interface is implemented by the servlet container in order to pass configuration information to a servlet. The server passes an object that implements the ServletConfig interface to the servlet''s init () method. A ServletContext defines a set of methods that a servlet uses to communicate with its servlet container.',1);
insert into Answers values(290,290,'Ans)
The difference is:


A forward is performed internally by the servlet. A redirect is a two step process, where the web application instructs the browser to fetch a second URL, which differs from the original.

The browser is completely unaware that it has taken place, so its original URL remains intact. But in sendRedirect, the browser, in this case, is doing the work and knows that it''s making a new request.',1);
insert into Answers values(291,291,'Ans)
The RequestDispatcher include() method inserts the contents of the specified resource directly in the flow of the servlet response, as if it were part of the calling servlet. The RequestDispatcher forward() method is used to show a different resource in place of the servlet that was originally called.',1);
insert into Answers values(292,292,'Ans)
The HttpServletRequestWrapper and HttpServletResponseWrapper classes are designed to make it easy for developers to create custom implementations of the servlet request and response types.
The classes are constructed with the standard HttpServletRequest and HttpServletResponse instances respectively and their default behaviour is to pass all method calls directly to the underlying objects.',1);
insert into Answers values(293,293,'Ans)
A deployment descriptor is an XML document with an .xml extension. It defines a component''s deployment settings. It declares transaction attributes and security authorization for an enterprise bean.
The information provided by a deployment descriptor is declarative and therefore it can be modified without changing the source code of a bean.',1);
insert into Answers values(294,294,'Ans)
A container does not initialize the servlets as soon as it starts up; it initializes a servlet when it receives a request for that servlet first time. This is called lazy loading.
The servlet specification defines the element, which can be specified in the deployment descriptor to make the servlet container load and initialize the servlet as soon as it starts up. The process of loading a servlet before any request comes in is called preloading or preinitializing a servlet.',1);
insert into Answers values(295,295,'Ans)
The <load-on-startup> element of a deployment descriptor is used to load a servlet file when the server starts instead of waiting for the first request. It is also used to specify the order in which the files are to be loaded.',1);
insert into Answers values(296,296,'Ans)
A session refers to all the requests that a single client might make to a server in the course of viewing any pages associated with a given application. Sessions are specific to both the individual user and the application.',1);
insert into Answers values(297,297,'Ans)
Session tracking is a mechanism that servlets use to maintain state about a series of requests from the same user (requests originating from the same browser) across some period of time.',1);
insert into Answers values(298,298,'Ans)
HTTP is a stateless protocol. Every request is treated as new request. For web applications to be more realistic they have to retain information across multiple requests. Such information which is part of the application is referred as "state". To keep track of this state we need session tracking.',1);
insert into Answers values(299,299,'Ans)
Different types are:


URL rewriting

Hidden Form Fields

Cookies

Secure Socket Layer (SSL) Sessions',1);
insert into Answers values(300,300,'Ans)
In a servlet, the HttpServletResponse and HttpServletRequest objects passed to method HttpServlet. Service () can be used to create cookies on the client and use cookie information transmitted during client requests. JSPs can also use cookies, in scriptlet code or, preferably, from within custom tag code.


To set a cookie on the client, use the addCookie() method in class HttpServletResponse. Multiple cookies may be set for the same request, and a single cookie name may have multiple values.

To get all of the cookies associated with a single HTTP request, use the getCookies() method of class HttpServletRequest',1);
insert into Answers values(301,301,'Ans)
Cookies are usually persistent, so for low-security sites, user data that needs to be stored long-term (such as a user ID, historical information, etc.) can be maintained easily with no server interaction. 
For small- and medium-sized session data, the entire session data (instead of just the session ID) can be kept in the cookie.',1);
insert into Answers values(302,302,'Ans)
URL rewriting is a method of session tracking in which some extra data is appended at the end of each URL. This extra data identifies the session. The server can associate this session identifier with the data it has stored about that session.',1);
insert into Answers values(303,303,'Ans)
Using session.invalidate() method.',1);
insert into Answers values(304,304,'Ans)
A container does not initialize the servlets as soon as it starts up; it initializes a servlet when it receives a request for that servlet first time. This is called lazy loading.',1);
insert into Answers values(305,305,'Ans)
Servlet Chaining is a method where the output of one servlet is piped into a second servlet. The output of the second servlet could be piped into a third servlet, and so on. The last servlet in the chain returns the output to the Web browser',1);
insert into Answers values(306,306,'Ans)
Filters are Java components that are used to intercept an incoming request to a Web resource and a response sent back from the resource. It is used to abstract any useful information contained in the request or response.',1);
insert into Answers values(307,307,'Ans)
The advantage of JSP is that they are document-centric. Servlets, on the other hand, look and act like programs. A Java Server Page can contain Java program fragments that instantiate and execute Java classes, but these occur inside an HTML template file and are primarily used to generate dynamic content.
Some of the JSP functionality can be achieved on the client, using JavaScript. The power of JSP is that it is server-based and provides a framework for Web application development.',1);
insert into Answers values(308,308,'Ans)
Life cyle of jsp:


Translation

Compilation

Loading the class

Instantiating the class

jspInit()

_jspService()

jspDestroy()',1);
insert into Answers values(309,309,'Ans)
The jspInit() method of the javax.servlet.jsp.JspPage interface is similar to the init() method of servlets. This method is invoked by the container only once when a JSP page is initialized. It can be overridden by a page author to initialize resources such as database and network connections, and to allow a JSP page to read persistent configuration data.',1);
insert into Answers values(310,310,'Ans)
The _jspService() method of the javax.servlet.jsp.HttpJspPage interface is invoked every time a new request comes to a JSP page. This method takes the HttpServletRequest and HttpServletResponse objects as its arguments. A page author cannot override this method, as its implementation is provided by the container.',1);
insert into Answers values(311,311,'Ans)
The jspDestroy() method of the javax.servlet.jsp.JspPage interface is invoked by the container when a JSP page is about to be destroyed. This method is similar to destroy() method of servlets. It can be overridden by a page author to perform any cleanup operation such as closing a database connection.',1);
insert into Answers values(312,312,'Ans)
You cannot override the _jspService() method within a JSP page. You can however, override the jspInit() and jspDestroy() methods within a JSP page. JspInit() can be useful for allocating resources like database connections, network connections, and so forth for the JSP page. It is good programming practice to free any allocated resources within jspDestroy().',1);
insert into Answers values(313,313,'Ans)
Implicit objects in JSP are the Java objects that the JSP Container makes available to developers in each page. These objects need not be declared or instantiated by the JSP author. They are automatically instantiated by the container and are accessed using standard variables; hence, they are called implicit objects.',1);
insert into Answers values(314,314,'Ans)
These implicit objects are available in jsp:


Request

Response

PageContext

session

application

Out

config

page

exception',1);
insert into Answers values(315,315,'Ans)
JSP directives are messages for the JSP engine. i.e., JSP directives serve as a message from a JSP page to the JSP container and control the processing of the entire page.
They are used to set global values such as a class declaration, method implementation, output content type, etc. They do not produce any output to the client.',1);
insert into Answers values(316,316,'Ans)
Page Directive is:


A page directive is to inform the JSP engine about the headers or facilities that page should get from the environment.

The page directive is found at the top of almost all of our JSP pages.

There can be any number of page directives within a JSP page (although the attribute – value pair must be unique).

The syntax of the include directive is: <%@ page attribute="value">',1);
insert into Answers values(317,317,'Ans)
There are thirteen attributes defined for a page directive of which the important attributes are as follows:


Import:
It specifies the packages that are to be imported.

Session:
It specifies whether a session data is available to the JSP page.

ContentType:
It allows a user to set the content-type for a page.

IsELIgnored:
It specifies whether the EL expressions are ignored when a JSP is translated to a servlet.',1);
insert into Answers values(318,318,'Ans)
Include directive is used to statically insert the contents of a resource into the current JSP. This enables a user to reuse the code without duplicating it, and includes the contents of the specified file at the translation time.',1);
insert into Answers values(319,319,'Ans)
The JSP standard actions affect the overall runtime behaviour of a JSP page and also the response sent back to the client. They can be used to include a file at the request time, to find or instantiate a Java Bean, to forward a request to a new page, to generate a browser-specific code, etc.',1);
insert into Answers values(320,320,'Ans)
The standards actions include:


<jsp:include>

<jsp:forward>

<jsp:useBean>

<jsp:setProperty>

<jsp:getProperty>

<jsp:param>

<jsp:plugin>',1);
insert into Answers values(321,321,'Ans)
The <jsp: useBean> standard action is used to locate an existing Java Bean or to create a Java Bean if it does not exist. It has attributes to identify the object instance, to specify the lifetime of the bean, and to specify the fully qualified class path and type.',1);
insert into Answers values(322,322,'Ans)
Scope includes:


Page scope

Request scope

application scope

session scope',1);
insert into Answers values(323,323,'Ans)
The <jsp:forward> standard action forwards a response from a servlet or a JSP page to another page. The execution of the current page is stopped and control is transferred to the forwarded page.',1);
insert into Answers values(324,324,'Ans)
The <jsp: include> standard action enables the current JSP page to include a static or a dynamic resource at runtime. In contrast to the include directive, include action is used for resources that change frequently. The resource to be included must be in the same context.',1);
insert into Answers values(325,325,'Ans)
The difference is:


Include directive, includes the content of the specified file during the translation phase–when the page is converted to a servlet. Include action, includes the response generated by executing the specified page (a JSP page or a servlet) during the request processing phase–when the page is requested by a user.

Include directive is used to statically insert the contents of a resource into the current JSP.  Include standard action enables the current JSP page to include a static or a dynamic resource at runtime.',1);
insert into Answers values(326,326,'Ans)
The <jsp: include> standard action and the pageContext.include() method are both used to include resources at runtime. However, the pageContext.include () method always flushes the output of the current page before including the other components, whereas <jsp: include> flushes the output of the current page only if the value of flush is explicitly set to true.',1);
insert into Answers values(327,327,'Ans)
You use jsp: setProperty to give values to properties of beans that have been referenced earlier.',1);
insert into Answers values(328,328,'Ans)
The <jsp: getProperty> action is used to access the properties of a bean that was set using the
action. The container converts the property to a String as follows:

If it is an object, it uses the toString() method to convert it to a String. If it is a primitive, it converts it directly to a String using the valueOf() method of the corresponding Wrapper class.

The syntax of the <jsp: getProperty> method is: <jsp: getProperty name="Name" property="Property" />',1);
insert into Answers values(329,329,'Ans)
The <jsp: param> standard action is used with <jsp: include> or <jsp: forward> to pass parameter names and values to the target resource.',1);
insert into Answers values(330,330,'Ans)
This action lets you insert the browser-specific OBJECT or EMBED element needed to specify that the browser run an applet using the Java plugin.',1);
insert into Answers values(331,331,'Ans)
JSP scripting elements let you insert Java code into the servlet that will be generated from the current JSP page.


Expressions

Scriptlet

Declarations

comment',1);
insert into Answers values(332,332,'Ans)
A scriptlet contains Java code that is executed every time a JSP is invoked. When a JSP is translated to a servlet, the scriptlet code goes into the service() method.
Hence, methods and variables written in scriptlet are local to the service() method. A scriptlet is written between the <% and %>tags and is executed by the container at request processing time.',1);
insert into Answers values(333,333,'Ans)
JSP declarations are used to declare class variables and methods in a JSP page. They are initialized when the class is initialized. Anything defined in a declaration is available for the whole JSP page. A declaration block is enclosed between the <%! and %>tags. A declaration is not included in the service() method when a JSP is translated to a servlet.',1);
insert into Answers values(334,334,'Ans)
A JSP expression is used to write an output without using the out.print statement. It can be said as a shorthand representation for scriptlet. An expression is written between the <%= and %> tags. It is not required to end the expression with a semicolon, as it implicitly adds a semicolon to all the expressions within the expression tags.',1);
insert into Answers values(335,335,'Ans)
Scripting is disabled by setting the scripting-invalid element of the deployment descriptor to true. It is a subelement of jsp-property-group. Its valid values are true and false.',1);
insert into Answers values(336,336,'Ans)
_jspService() method will be written by the container hence any methods which are not to be overridden by the end user are typically written starting with a ''_''. This is the reason why we don''t override _jspService() method in any JSP page.',1);
insert into Answers values(337,337,'Ans)
Add jsp_precompile as a request parameter and send a request to the JSP file. This will make the jsp pre-compile.
http://localhost:8080/jsp1/test.jsp?jsp_precompile=true

It causes execution of JSP life cycle until jspInit() method without executing _jspService() method.',1);
insert into Answers values(338,338,'Ans)
It removes the start-up lag that occurs when a container must translate a JSP page upon receipt of the first request.',1);
insert into Answers values(339,339,'Ans)
Variable declared inside declaration part is treated as a instance variable and will be placed directly at class level in the generated servlet. Variable declared in a scriptlet will be placed inside _jspService () method of generated servlet. It acts as local variable.',1);
insert into Answers values(340,340,'Ans)
These are the three types of commenst in jsp:


JSP Comment:  <%-- this is jsp comment -- %>
HTML Comment: <!--  this is HTMl comment -- >
Java Comments:
<%
 // single line java comment
/* this is multiline comment */
%>',1);
insert into Answers values(341,341,'Ans)
The comment which is visible in the source of the response is called output comment.
     <!--  this is HTMl comment -- >',1);
insert into Answers values(342,342,'Ans)
This is also known as JSP comment and it is visible only in the JSP and in rest of phases of JSP life cycle it is not visible.
  <%-- this is jsp comment -- %>',1);
insert into Answers values(343,343,'Ans)
You can use the errorPage attribute of the page directive to have uncaught run-time exceptions automatically forwarded to an error processing page.',1);
insert into Answers values(344,344,'Ans)
You can make your JSPs thread-safe by having them implement the SingleThreadModel interface. This is done by adding the directive in the JSP.
  <%@ page isThreadSafe="false" %>',1);
insert into Answers values(345,345,'Ans)
Yes, there is. The page implicit object is equivalent to "this", and returns a reference to the generated servlet.',1);
insert into Answers values(346,346,'Ans)
Yes. By using getOutputStream () method on response implicit object we can get it.',1);
insert into Answers values(347,347,'Ans)
This command is used to autoflush the contents. If a value of true is used it indicates to flush the buffer whenever it is full. In case of false it indicates that an exception should be thrown whenever the buffer is full. If you are trying to access the page at the time of conversion of a JSP into servlet will result in error.',1);
insert into Answers values(348,348,'Ans)
The different scopes are:


Page:
Within the same page.

Request:
After forward or include also you will get the request scope data.

Session:
After sendRedirect also you will get the session scope data. All data stored in session is available to end user till session closed or browser closed.

Application:
Data will be available throughout the application. One user can store data in application scope and other can get the data from application scope.',1);
insert into Answers values(349,349,'Ans)
If we want to make our data available to the entire application then we have to use application scope.',1);
insert into Answers values(350,350,'Ans)
No problem! The use Bean action specifies the bean Name attribute, which can be used for indicating a serialized bean.',1);
insert into Answers values(351,351,'Ans)
If the target resource won’t change frequently, then it is recommended to use include directives.
If the target resource will change frequently, then it is recommended to use include action.',1);
insert into Answers values(352,352,'Ans)
Java Database Connectivity (JDBC) is a standard Java API to interact with relational databases form Java. JDBC has set of classes and interfaces which can use from Java application and talk to database without learning RDBMS details and using Database Specific JDBC Drivers',1);
insert into Answers values(353,353,'Ans)
The basic steps are:


Load the RDBMS specific JDBC driver because this driver actually communicates with the database.

Open the connection to database which is then used to send SQL statements and get results back.

Create JDBC Statement object. This object contains SQL query.

Execute statement which returns resultset(s). Resultset contains the tuples of database table as a result of SQL query.

Process the result set.

Close the connection.',1);
insert into Answers values(354,354,'Ans)
The main components are:


DriverManager

Driver

Connection

Statement

Resultset',1);
insert into Answers values(355,355,'Ans)
DriverManager is a static class. It manages a list of database drivers. Matches connection requests from the java application with the proper database driver using communication sub protocol. The first driver that recognizes a certain sub protocol under JDBC will be used to establish a database Connection.',1);
insert into Answers values(356,356,'Ans)
The JDBC API defines the Java interfaces and classes that programmers use to connect to databases and send queries. A JDBC driver implements these interfaces and classes for a particular DBMS vendor.database communications link, handling all communication with the database.
Normally, once the driver is loaded, the developer need not call it explicitly.',1);
insert into Answers values(357,357,'Ans)
Interface with all methods for contacting a database. The connection object represents communication context, i.e., all communication with database is through connection object only',1);
insert into Answers values(358,358,'Ans)
Encapsulates an SQL statement which is passed to the database.',1);
insert into Answers values(359,359,'Ans)
The Resultset represents set of rows retrieved due to query execution.',1);
insert into Answers values(360,360,'Ans)
Provided the JAR file containing the driver is properly configured, just place the JAR file in the classpath. Java developers NO longer need to explicitly load JDBC drivers using code like Class.forName() to register a JDBC driver.
The DriverManager class takes care of this by automatically locating a suitable driver when the DriverManager.getConnection() method is called. This feature is backward-compatible, so no changes are needed to the existing JDBC code.',1);
insert into Answers values(361,361,'Ans)
The JDBC Driver interface provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each vendor driver must provide implementations of the java.sql.Connection,Statement,PreparedStatement, CallableStatement, ResultSet and Driver',1);
insert into Answers values(362,362,'Ans)
The connection object represents communication context, i.e., all communication with database is through connection object only.',1);
insert into Answers values(363,363,'Ans)
Statement acts like a vehicle through which SQL commands can be sent. Through the connection object we create statement kind of objects.',1);
insert into Answers values(364,364,'Ans)
A prepared statement is an SQL statement that is precompiled by the database. Through precompilation, prepared statements improve the performance of SQL commands that are executed multiple times. Once compiled, prepared statements can be customized prior to each execution by altering predefined SQL parameters.',1);
insert into Answers values(365,365,'Ans)
The difference is:


A standard Statement is used to create a Java representation of a literal SQL statement and execute it on the database. A PreparedStatement is a precompiled statement. This means that when the PreparedStatement is executed, the RDBMS can just run the PreparedStatement SQL statement without having to compile it first.

Statement has to verify its metadata against the database every time. While a prepared statement has to verify its metadata against the database only once.

If you want to execute the SQL statement once go for STATEMENT. If you want to execute a single SQL statement multiple number of times, then go for PREPAREDSTATEMENT. PreparedStatement objects can be reused with passing different values to the queries',1);
insert into Answers values(366,366,'Ans)
Callable statements are used from JDBC application to invoke stored procedures and functions.',1);
insert into Answers values(367,367,'Ans)
PL/SQL stored procedures are called from within JDBC programs by means of the prepareCall() method of the Connection object created. A call to this method takes variable bind parameters as input parameters as well as output variables and creates an object instance of the CallableStatement class.',1);
insert into Answers values(368,368,'Ans)
The types are:


Type 1: JDBC/ODBC

Type2: Native API (partly-Java driver)

Type 3: Open Protocol-Net

Type 4: Proprietary Protocol-Net(pure Java driver)',1);
insert into Answers values(369,369,'Ans)
JDBC Net pure Java driver(Type IV) is the fastest driver because it converts the JDBC calls into vendor specific protocol calls and it directly interacts with the database.',1);
insert into Answers values(370,370,'Ans)
No, You can open only one Statement object per connection when you are using the JDBC-ODBC Bridge.',1);
insert into Answers values(371,371,'Ans)
The standard isolation levels are:


TRANSACTION_NONE

TRANSACTION_READ_COMMITTED

TRANSACTION_READ_UNCOMMITTED

TRANSACTION_REPEATABLE_READ

TRANSACTION_SERIALIZABLE',1);
insert into Answers values(372,372,'Ans)
The ResultSet represents set of rows retrieved due to query execution.
Example: ResultSetrs = stmt.executeQuery(sqlQuery);',1);
insert into Answers values(373,373,'Ans)
The types are:


TYPE_FORWARD_ONLY specifies that a resultset is not scrollable, that is, rows within it can be advanced only in the forward direction.

TYPE_SCROLL_INSENSITIVE specifies that a resultset is scrollable in either direction but is insensitive to changes committed by other transactions or other statements in the same transaction.

TYPE_SCROLL_SENSITIVE specifies that a resultset is scrollable in either direction and is affected by changes committed by other transactions or statements within the same transaction.',1);
insert into Answers values(374,374,'Ans)
An insensitive resultset is like the snapshot of the data in the database when query was executed. A sensitive resultset does NOT represent a snapshot of data; rather it contains points to those rows which satisfy the query condition.
After we get the resultset the changes made to data are not visible through the resultset, and hence they are known as insensitive. After we obtain the resultset if the data is modified then such modifications are visible through resultset.',1);
insert into Answers values(375,375,'Ans)
A RowSet is an object that encapsulates a set of rows from either Java Database Connectivity (JDBC) result sets or tabular data sources like a file or spreadsheet. RowSets support component-based development models like JavaBeans, with a standard set of properties and an event notification mechanism.',1);
insert into Answers values(376,376,'Ans)
The different types are:


Connected - A connected RowSet object connects to the database once and remains connected until the application terminates.

Disconnected - A disconnected RowSet object connects to the database, executes a query to retrieve the data from the database and then closes the connection. A program may change the data in a disconnected RowSet while it is disconnected. Modified data can be updated in the database after a disconnected RowSet re-establishes the connection with the database.',1);
insert into Answers values(377,377,'Ans)
The BatchUpdates feature allows us to group SQL statements together and send to database server in one single trip.',1);
insert into Answers values(378,378,'Ans)
A DataSource object is the representation of a data source in the Java programming language. In basic terms,


A DataSource is a facility for storing data.

DataSource can be referenced by JNDI.

Data Source may point to RDBMS; file System, any DBMS etc.',1);
insert into Answers values(379,379,'Ans)
The advantages are:


An application does not need to hardcode driver information, as it does with the DriverManager.

The DataSource implementations can easily change the properties of data sources.

The DataSource facility allows developers to implement a DataSource class to take advantage of features like connection pooling and distributed transactions.',1);
insert into Answers values(380,380,'Ans)
A connection pool is a mechanism to reuse connections created. Connection pooling can increase performance dramatically by reusing connections rather than creating a new physical connection each time a connection is requested.',1);
insert into Answers values(381,381,'Ans)
Multiprogramming is a rapid switching of the CPU back and forth between processes.',1);
insert into Answers values(382,382,'Ans)
TCP is designed to provide reliable communication across a variety of reliable and unreliable networks and internets.UDP provides a connectionless so it isbasically an unreliable service. Delivery and duplicate protection are not guaranteed.',1);
insert into Answers values(383,383,'Ans)
The combination of an IP address and a port number is called a socket.',1);
insert into Answers values(384,384,'Ans)
The advantages are:


Sockets are flexible and sufficient.

Efficient socket based programming can be easily implemented for general communications.

Sockets cause low network traffic.',1);
insert into Answers values(385,385,'Ans)
The disadvantages are:


Security restrictions are sometimes overbearing because a Java applet running in a Web browser is only able to establish connections to the machine where it came from, and to nowhere else on the network.

Despite all of the useful and helpful Java features, Socket based communications allows only to send packets of raw data between applications. Both the client-side and server-side have to provide mechanisms to make the data useful in any way.

Since the data formats and protocols remain application specific, the re-use of socket based implementations is limited.',1);
insert into Answers values(386,386,'Ans)
It stands for Remote Method Invocation. RMI is a set of APIs that allows to build distributed applications. RMI uses interfaces to define remote objects to turn local method invocations into remote method invocations.',1);
insert into Answers values(387,387,'Ans)
The socket () is very similar to socketPair() except that only one socket is created instead of two. This is most commonly used when if the process you wish to communicate with is not the child process.',1);
insert into Answers values(388,388,'Ans)
The ServerSocket class is used to create serverSocket. This object is used to communicate with client.',1);
insert into Answers values(389,389,'Ans)
It binds the socket to the specified server and port in the SocketAddress object. Use this method if you instantiated the ServerSocket using the no-argument constructor.',1);
insert into Answers values(390,390,'Ans)
A datagram is an independent, self-contained message sent over the network whose arrival, arrival time, and content are not guaranteed.',1);
insert into Answers values(391,391,'Ans)
It returns the port that the server socket is listening on. This method is useful if you passed in 0 as the port number in a constructor and let the server find a port for you.',1);
insert into Answers values(392,392,'Ans)
It waits for an incoming client. This method blocks until either a client connects to the server on the specified port or the socket times out, assuming that the time-out value has been set using the setSoTimeout() method. Otherwise, this method blocks indefinitely.',1);
insert into Answers values(393,393,'Ans)
A network interface is the point of interconnection between a computer and a private or public network. A network interface is generally a network interface card (NIC), but does not have to have a physical form.',1);
insert into Answers values(394,394,'Ans)
Hiding data within the class and making it available only through the methods. This technique is used to protect your class against accidental changes to fields, which might leave the class in an inconsistent state.',1);
insert into Answers values(395,395,'Ans)
It occurs when two or more processes are reading or writing some shared data and the final result depends on who runs precisely when.',1);
insert into Answers values(396,396,'Ans)
Socket is created from this information:

Local System''s: IP Address and Port Number

Remote System''s: IPAddress and Port Number',1);
